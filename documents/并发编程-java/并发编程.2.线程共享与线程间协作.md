[TOC]

# 线程的共享与线程间协作

> JVM中的线程是**协作式**的

## 基本概念

### 原子性

　**原子是世界上的最小单位，具有不可分割性。**

> 比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。
>
> 再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以它不是一个原子操作。

### 可见性

> ​	可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。
>
> 　　**可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。**也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。

#### 一段“看不见”的代码

```java
public class NoVisibility {
    // 告诉JVM flag是个善变的变量，需要我们盯住它
	static /*volatile*/ boolean flag;
	static int count = 0;
	
	private static class NoVisibilityThread extends Thread {
		@Override
		public void run() {
			System.out.println("进入线程run()");
			while (!flag) {}; // 死循环
			System.out.println(count);
		}
	}
	
	
	public static void main(String[] args) throws InterruptedException {
		new NoVisibilityThread().start();
		Thread.sleep(10); // 休眠10ms 保证在flag = true前进入循环
		count = 10;
		flag = true;
		Thread.sleep(10); // 休眠10ms 保证在执行完 flag = true 后进入线程时间片
		System.out.println("主线程执行完毕");
	}
}
```

### **有序性**

> `Java` 语言提供了 `volatile` 和 `synchronized` 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，
>
> `synchronized` 是由“一个变量在同一个时刻只允许一条线程对其进行 *lock* 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。

## synchronized 内置锁

### 使用方式

#### 修饰方法

```java
public synchronized void sayHello(){}
```

#### 修饰代码块

```java
public void sayHello() {
    synchronized(lock){
        System.out.println(hello);
    }
}
```

### 对象锁与类锁

- 对象锁

  使用`对象实例`作为锁；

- 类锁

  使用`Class对象实例`作为锁，即直接使用`synchronized`修饰方法

### 错误使用synchronized

```java
/**
 返回以对象内存地址计算得出hash值,可近似认为内存地址
 该方法可在Object中hashCode()方法重写后使用
*/
System.identityHashCode(object); 
```

#### 错误代码 - 基本类型包装类引发的线程错误

```java
/**
 * 类说明：错误的加锁和原因分析
 */
public class TestIntegerSyn {

    public static void main(String[] args) throws InterruptedException {
        Worker worker=new Worker(1);
        //Thread.sleep(50);
        for(int i=0;i<5;i++) {
            new Thread(worker).start();
        }
    }

    private static class Worker implements Runnable{

        private Integer i;
        // private Object o = new Object();

        public Worker(Integer i) {
            this.i=i;
        }

        @Override
        public void run() {
            synchronized (o) {
                Thread thread=Thread.currentThread();
                System.out.println(thread.getName()+"--@"
                        +System.identityHashCode(i));
                i++; // 错误关键代码
                System.out.println(thread.getName()+"-------"+i+"-@"
                        +System.identityHashCode(i));
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(thread.getName()+"-------"+i+"--@"
                        +System.identityHashCode(i));
            }

        }

    }

}
```

- 执行结果

```java
Thread-0--@7051476
Thread-0-------2-@246179497
Thread-0-------2--@246179497
Thread-4--@246179497
Thread-4-------3-@1913323607
Thread-4-------3--@1913323607
Thread-3--@1913323607
Thread-3-------4-@1518908764
Thread-3-------4--@1518908764
Thread-2--@1518908764
Thread-2-------5-@714548956
Thread-2-------5--@714548956
Thread-1--@714548956
Thread-1-------6-@731692489
Thread-1-------6--@731692489
```

很明显输出结果并未如我们预料般有序输出，其次注意对象内存地址发生变化。

- 错误原因

`Integer`源码 - 或通过反编译生成字节码查看实际运行代码

```java
public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
}
```

`Integet`导致每次将返回一个新对象，导致我们每次对不同的对象上锁，从而引发线程安全问题。

- 解决方法

```java
// Integer i;
Object o = new Object(); // 要求我们的'锁'不会发生变化
```

## volatile 最轻量同步机制

`volatile` 易变的, 无常的。保证`可见性`

- 百度

> **volatile**的作用是作为指令[关键字](https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E5%AD%97/7105697)，确保本条指令不会因[编译器](https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8/8853067)的优化而省略，且要求每次直接读值。

- [郑州的文武]

> 　　Java语言提供了一种稍弱的同步机制，即`volatile`变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为`volatile`类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。`volatile`变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取`volatile`类型的变量时总会返回最新写入的值。
>
> 　　在访问`volatile`变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此`volatile`变量是一种比`sychronized`关键字更轻量级的同步机制。
>
> ​	当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到`CPU缓存`中。如果计算机有多个`CPU`，每个线程可能在不同的`CPU`上被处理，这意味着每个线程可以拷贝到不同的`CPU cache`中。
>
> 　　而声明变量是 `volatile` 的，`JVM` 保证了每次读变量都从内存中读，跳过`CPU cache`这一步。

### 应用场景

一个线程写，多个线程读。这让我一下联想到`分布式数据库`中的`master-salve`

### 参考

https://baike.baidu.com/item/volatile/10606957?fr=aladdin

https://www.cnblogs.com/zhengbin/p/5654805.html