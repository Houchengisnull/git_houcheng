[TOC]

# 线程的共享

> JVM中的线程是**协作式**的

## 基本概念

### 原子性

　**原子是世界上的最小单位，具有不可分割性。**

> 比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。
>
> 再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以它不是一个原子操作。

### 可见性

> ​	可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。
>
> 　　**可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。**也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。

#### 一段“看不见”的代码

```java
public class NoVisibility {
    // 告诉JVM flag是个善变的变量，需要我们盯住它
	static /*volatile*/ boolean flag;
	static int count = 0;
	
	private static class NoVisibilityThread extends Thread {
		@Override
		public void run() {
			System.out.println("进入线程run()");
			while (!flag) {}; // 死循环
			System.out.println(count);
		}
	}
	
	
	public static void main(String[] args) throws InterruptedException {
		new NoVisibilityThread().start();
		Thread.sleep(10); // 休眠10ms 保证在flag = true前进入循环
		count = 10;
		flag = true;
		Thread.sleep(10); // 休眠10ms 保证在执行完 flag = true 后进入线程时间片
		System.out.println("主线程执行完毕");
	}
}
```

### **有序性**

> `Java` 语言提供了 `volatile` 和 `synchronized` 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，
>
> `synchronized` 是由“一个变量在同一个时刻只允许一条线程对其进行 *lock* 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。

## synchronized 内置锁

### 使用方式

#### 修饰方法

```java
public synchronized void sayHello(){}
```

#### 修饰代码块

```java
public void sayHello() {
    synchronized(lock){
        System.out.println(hello);
    }
}
```

### 对象锁与类锁

- 对象锁

  使用`对象实例`作为锁；

- 类锁

  使用`Class对象实例`作为锁，即直接使用`synchronized`修饰方法

### 错误使用synchronized

```java
/**
 返回以对象内存地址计算得出hash值,可近似认为内存地址
 该方法可在Object中hashCode()方法重写后使用
*/
System.identityHashCode(object); 
```

#### 错误代码 - 基本类型包装类引发的线程错误

```java
/**
 * 类说明：错误的加锁和原因分析
 */
public class TestIntegerSyn {

    public static void main(String[] args) throws InterruptedException {
        Worker worker=new Worker(1);
        //Thread.sleep(50);
        for(int i=0;i<5;i++) {
            new Thread(worker).start();
        }
    }

    private static class Worker implements Runnable{

        private Integer i;
        // private Object o = new Object(); // 解决方法

        public Worker(Integer i) {
            this.i=i;
        }

        @Override
        public void run() {
            synchronized(i) {
            // synchronized (o) { //解决方法
                Thread thread=Thread.currentThread();
                System.out.println(thread.getName()+"--@"
                        +System.identityHashCode(i));
                i++; // 错误关键代码
                System.out.println(thread.getName()+"-------"+i+"-@"
                        +System.identityHashCode(i));
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(thread.getName()+"-------"+i+"--@"
                        +System.identityHashCode(i));
            }

        }

    }

}
```

- 执行结果

```java
Thread-0--@7051476
Thread-0-------2-@246179497
Thread-0-------2--@246179497
Thread-4--@246179497
Thread-4-------3-@1913323607
Thread-4-------3--@1913323607
Thread-3--@1913323607
Thread-3-------4-@1518908764
Thread-3-------4--@1518908764
Thread-2--@1518908764
Thread-2-------5-@714548956
Thread-2-------5--@714548956
Thread-1--@714548956
Thread-1-------6-@731692489
Thread-1-------6--@731692489
```

很明显输出结果并未如我们预料般有序输出，其次注意对象内存地址发生变化。

- 错误原因

`Integer`源码 - 或通过反编译生成字节码查看实际运行代码

```java
public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
}
```

`Integet`导致每次将返回一个新对象，导致我们每次对不同的对象上锁，从而引发线程安全问题。

- 解决方法

```java
// Integer i;
Object o = new Object(); // 要求我们的'锁'不会发生变化
```

## 显式锁

Lock对象必须被显式的创建，锁定和释放。

因此，它与内建的锁形式相比，代码缺乏优雅性

- Example

``` java
private Lock lock = new ReetrantLock();

public int next(){
	lock.lock();
	try{
		Thread.yield()
	}finally{
		lock.unlock();
	}
}
```

如果在使用synchronized时，某些事物失败了，那么会抛出一个异常。

但是程序员没有机会去做任何清理工作，以维护系统使其处于良好状态。



大体上，当你使用synchronized关键字时，需要写的代码量更少，并且用户错误出现的可能性会降低；

## volatile 最轻量同步机制

`volatile` 易变的, 无常的。保证`可见性`

- 百度

> **volatile**的作用是作为指令[关键字](https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E5%AD%97/7105697)，确保本条指令不会因[编译器](https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8/8853067)的优化而省略，且要求每次直接读值。

- [郑州的文武]

> 　　Java语言提供了一种稍弱的同步机制，即`volatile`变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为`volatile`类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。`volatile`变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取`volatile`类型的变量时总会返回最新写入的值。
>
> 　　在访问`volatile`变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此`volatile`变量是一种比`sychronized`关键字更轻量级的同步机制。
>
> ​	当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到`CPU缓存`中。如果计算机有多个`CPU`，每个线程可能在不同的`CPU`上被处理，这意味着每个线程可以拷贝到不同的`CPU cache`中。
>
> 　　而声明变量是 `volatile` 的，`JVM` 保证了每次读变量都从内存中读，跳过`CPU cache`这一步。

### 应用场景

一个线程写，多个线程读。这让我一下联想到`分布式数据库`中的`master-salve`

### 参考

https://baike.baidu.com/item/volatile/10606957?fr=aladdin

https://www.cnblogs.com/zhengbin/p/5654805.html

## ThreadLocal

在类中声明一个`static ThreadLocal<Integer> intLocal;`与`static int i;`。

其中**i**对于所有线程都是“平等”的；而**intLocal**则允许每个线程持有一个属于自己的Integer对象。

而ThreadLocal的实现思路就是实现Java线程的私有变量。

> 其非常适用于同一线程中，不同开发层次中共享数据。
>
> （from:https://www.cnblogs.com/listened/p/5031478.html）

### 与synchronized比较

`ThreadLocal`与`synchronized`均用于解决多线程并发访问。

- synchronized

  `synchronized`利用锁的机制，使变量和代码块在某一时刻仅能被一个线程访问；

- ThreadLocal

  `ThreadLocal`为每个线程提供了变量的副本，使得线程在某一时间访问的并非同一对象，以隔离多个线程对数据的数据共享；

### 应用场景

- Spring事务

  `Spring`将从连接池中获取一个`Connection`对象，然后将这个对象放入`ThreadLocal`与线程绑定。若`Spring`不使用`ThreadLocal`，在同一`Service`调用一些列`Dao`时，需要保证在这个`Service`中仅使用一个连接以满足在这个过程中对数据操作的一致性。

  且Web容器中，每个完整的请求周期由一个线程来处理。我们将变量(例如Connection对象)绑定到线程中，就能很好地实现软件架构中的跨层次参数共享（隐式共享）——ThreadLocal。

  结合Spring IOC与AOP，就能很好解决这一点。

### 使用方式

- void set(Object value)

- public Object get()

- public void remove()

  将当前线程局部变量删除，目的是为了减少内存占用，该方法为JDK5新增方法。同时线程结束后，对于该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程非必须操作，但它能加速内存回收速度。

- protected Object initialValue()

  返回该线程局部变量的初始值。该方法是一个protected方法，显然是为了让子类覆盖而设计。这个方法是一个延时调用的方法，在线程第一次调用get()或者set(Object value)时才执行，并且仅执行1次。ThreadLocal的缺省实现是返回一个null。

  ``` java
  protected T initialValue() {
      return null;
  }
  ```

``` java
/**
* resource为一个存放String的ThreadLocal对象，不论何时任一线程对它进行读写操作均为线程安全的。
*/
public final static ThreadLocal<String> resource = new Thread<String>()
```

#### 为何将ThreadLocal声明为静态变量

常常见人们将`ThreadLocal`声明为静态变量——static。

``` java
private static ThreadLocal<Integer> intVal = new ThreadLocal<>();
```

首先修改当前`WithThreadLocal.java`代码中的静态内部类`TestThread`

``` java
public static class TestThread implements Runnable{
		int id;
		int intLocal = 1;
		public TestThread(int id){
		    this.id = id;
		}
		public void run() {
		    System.out.println(Thread.currentThread().getName()+":start");
		    Integer s = intLocal;
		    s = s+id;
		    intLocal = s;
		    System.out.println(Thread.currentThread().getName()
		            +":"+ intLocal);
		    //intLocal.remove();
		}
	}

```

由于变量`int intLocal`属于线程私有，与`ThreadLocal`实现思想（见下）一致，所以运行结果一致。但这种声明方式仅能在`Thread`或`Runnable`派生类中使用，缺乏灵活度。

- 将`ThreadLocal`作为成员变量存在相同问题。

- `ThreadLocal`本身被设计为多线程直接调用即可，这种隐式的使用方法令开发过程更便利。
- 实际保存变量的是线程内部的`ThreadLocalMap`，`ThreadLocal`的更像是两者之间的桥梁（*工具类*）。使用**static**关键字声明减小了`JVM`内存开销。

### 实现解析

``` java
 /**
     * Returns the value in the current thread's copy of this
     * thread-local variable.  If the variable has no value for the
     * current thread, it is first initialized to the value returned
     * by an invocation of the {@link #initialValue} method.
     *
     * @return the current thread's value of this thread-local
     */
    public T get() {
        Thread t = Thread.currentThread(); // 获取当前线程
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }

/**
     * Get the map associated with a ThreadLocal. Overridden in
     * InheritableThreadLocal.
     *
     * @param  t the current thread
     * @return the map
     */
    ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }
    
```

其中`ThreadLocalMap`是`ThreadLocal`静态内部类。再通过`getMap(Thread t)`方法返回线程成员变量（线程私有）。

``` java
// Thread类源码
/* ThreadLocal values pertaining to this thread. This map is maintained
     * by the ThreadLocal class. */
    ThreadLocal.ThreadLocalMap threadLocals = null;
```

- ThreadLocalMap源码

![1560263676665](https://github.com/Houchengisnull/helloWorld/blob/master/documents/images/并发-java/1560263676665.png)

其持有一个Entry内部静态类，继承`WeakReference`，它记录了两个信息——ThreadLocal<?>与Object。getEntry方法则是获取某个ThreadLocal对应的值，set方法即更新或复制相应的ThreadLocal的值。

``` java
private Entry getEntry(ThreadLocal<?> key) {
    		// 以ThreadLocal为键值进行位运算
            int i = key.threadLocalHashCode & (table.length - 1);
            /* 
            	获取相应ThreadLocal对象的value
    		 	可参考HashMap源代码加深理解
    		 	当遇到重复hash时调用nextHashCode()方法以避免碰撞
    		*/
    		Entry e = table[i];
            if (e != null && e.get() == key)
                return e;
            else
                return getEntryAfterMiss(key, i, e);
        }
```

![1560265052378](https://github.com/Houchengisnull/helloWorld/blob/master/documents/images/并发-java/1560265052378.png)

所以在调用ThreadLocal对象get方法时，实际现获取当前线程独有的`ThreadLocalMap`，再以ThreadLocal当前实例作为键值拿到Map中相应的Entry。

ThreadLocal是Java编写者对内部类应用的绝佳的演示。

![1561379674412](https://github.com/Houchengisnull/helloWorld/blob/master/documents/images/并发-java/threadLocal.jpg)

### 内存泄漏问题

#### Java中的各种引用

- 强引用

强引用在程序代码中普遍存在。只要强引用还存在，`垃圾回收器`便永远不会回收被引用的对象实例。

``` java
Object obj = new Object();
```

- 软引用

描述一些有用但非必需的对象。

在`JVM`将发生内存溢出前，将回收这些`软引用`指向的对象实例。如果此次回收之后依然没有足够的内存，才会抛出内存溢出异常。

`JDK1.2`提供`SoftReference`来实现软引用。

> - 内存溢出
>
>   程序申请内存时，没有足够的内存空间供其使用，出现`Out of Memory`。
>
> - 内存泄漏
>
>   程序在申请内存后，无法释放已申请的内存空间。一次内存泄露危害可以忽略，但内存泄漏堆积后果很严重。将会导致`Out of Memory`。

https://www.cnblogs.com/panxuejun/p/5883044.html

- 弱引用

只要发生`垃圾回收`，无论当前内存是否足够，`弱引用`一定被回收。

`JDK1.2`提供`WeakReference`类来实现弱引用。

- 虚引用

幽灵引用或幻影引用。它是最虚的一种引用，一个对象实例是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。

- 虚引用唯一的应用场景

  能令对象在被垃圾回收时收到一个系统通知。

`JDK1.2`提供`WeakReference`类来实现弱引用。

#### ThreadLocal内存泄漏场景

``` java

import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class ThreadLocalOOM {

    private static final int TASK_LOOP_SIZE = 500;
    final static ThreadPoolExecutor executor
            = new ThreadPoolExecutor(5, 5, 1, TimeUnit.MINUTES, new LinkedBlockingQueue());

    static class LocalVariable {
        private byte[] a = new byte[1024*1024*5];/*5M大小的数组*/
    }

    final static ThreadLocal<LocalVariable> localVariable = new ThreadLocal<>();

    public static void main(String[] args) throws InterruptedException {
        Object o = new Object();
        for (int i = 0; i < TASK_LOOP_SIZE; i++) {
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    new LocalVariable(); // 1
                    // localVariable.set(new LocalVariable); // 2
                    System.out.println("use local var");
                    // localVariable.remove(); // 3
                }
            });

            Thread.sleep(100);
        }
        System.out.println("pool execute over");
    }
}
```

通过`JDK/bin/jvisualVM`分别比较**注释1**、**注释2**、**注释3**的情况。

将发现仅使用**注释2**代码时内存消耗较大但上升有限制。

我们知道每个`Thread`维护一个`ThreadLocalMap`。这个映射表的key是`ThreadLocal`实例本身，value是真正需要存储的对象。

![1561379674412](https://github.com/Houchengisnull/helloWorld/blob/master/documents/images/并发-java/ThreadLocalLeak.png)

``` java
/**
         * The entries in this hash map extend WeakReference, using
         * its main ref field as the key (which is always a
         * ThreadLocal object).  Note that null keys (i.e. entry.get()
         * == null) mean that the key is no longer referenced, so the
         * entry can be expunged from table.  Such entries are referred to
         * as "stale entries" in the code that follows.
         */
        static class Entry extends WeakReference<ThreadLocal<?>> {
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal<?> k, Object v) {
                super(k);
                value = v;
            }
        }

```

查看源代码我们发现，``ThreadLocalMap`的key是一个弱引用对象，在发生垃圾回收后将不存在。如此一来，`ThreadLocalMap`中将出现key == null的Entry，而value就会一直占据着内存且`JVM`没有key可以找到它。这就发生了**内存泄漏**。

只有当前thread结束后，强引用断开，Current Thread及其Map value 全部被`GC`回收。所以在不需要使用`ThreadLocal`变量后，显式调用remove()清除数据。

> `remove()`方法的核心在调用 `expungeStaleEntry()`清除key为null的value。
>
> 而`get()`、`set()`在某些情况下同样会调用`expungeStaleEntry()`，但这是不及时的，也不是每次会执行。
>
> 所以一些情况还是会发生内存泄漏。

- 假设ThreadLocal为强引用

`ThreadLocal`对象被回收后，但`ThreadLocalMap`还持有`ThreadLocal`的强引用，如果没有手动删除，`ThreadLocal`的对象实例不会被回收，导致`Entry`内存泄漏。

> Mark:
>
> 比较两种情况，我们可以发现：由于`ThreadLocalMap`的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障。
>
> 因此，`ThreadLocal`内存泄漏的根源是：由于`ThreadLocalMap`的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。

**所以在使用池化思想解决问题时要考虑强引用对象的回收问题**

# 线程协作

- 业务场景

  线程A修改了对象B的状态，另一个线程B检测到B状态的改变，然后进行相应的操作。

整个过程开始于一个线程，最终执行时另一个线程。前者是生产者，后者是消费者。

- 实现

  最简单的实现方式便是轮询，又称`忙等待`。（volatile）

  但这种方式明显存在一个问题——系统资源的消耗与及时性呈反比例关系。

## 等待/通知机制

​		等待/通知模型能够很好地解决以上问题。

- `notify()`、`notifyAll()`

  调用notify与notifyAll不会立即释放锁，**直到当前synchronized代码块执行完毕，才释放锁**。

- `wait()`、`wait(long)`、`wait(long, int)`

  调用后将当前线程立即释放锁，进入阻塞状态。

以上方法为`Object类`中`final`方法。

> 《Java编程思想》
>
> wait()、notify()、notifyAll()有一个比较特殊的方面，那就是这些方法是基类Object的一部分，而不是Thread的一部分。尽管开始看起来有点奇怪——仅仅针对线程的功能却作为通用基类的一部分而实现，不过这是有道理的：因为这些方法操作的锁也是所有对象的一部分，所以你可以把wait()放到任何同步控制方法中，而不用考虑这个类是否继承自Thread还是实现了Runnable接口。

### 等待/通知标准范式

#### 等待方

等待方遵循原则

- 获取对象锁
- 如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。
- 条件满足则执行对应逻辑

``` java
synchronized (lock) {
    while(conditonal) {
        lock.wait();
    }
    // handle
}
```

#### 通知方

通知方遵循原则

- 获取对象锁
- 改变条件
- 通知所有等待在对象上的线程

``` java
synchronized (lock) {
    // change conditional
    
    /*
    	由于notify/notifyAll在synchronized执行完毕后方释放锁，
    	所以往往将该语句放在synchronized代码块最后一行。
    */
    lock.notifyAll();
}
```

> **如何选择notify和notifyAll**
>
> Mark:
>
> ​	尽可能用notifyall()，谨慎使用notify()，因为notify()只会唤醒一个线程，我们无法确保被唤醒的这个线程一定就是我们需要唤醒的线程