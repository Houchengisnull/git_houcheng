[TOC]

# 线程的共享与线程间协作

> JVM中的线程是**协作式**的

## 基本概念

### 原子性

　**原子是世界上的最小单位，具有不可分割性。**

> 比如 a=0；（a非long和double类型） 这个操作是不可分割的，那么我们说这个操作时原子操作。
>
> 再比如：a++； 这个操作实际是a = a + 1；是可分割的，所以它不是一个原子操作。

### 可见性

> ​	可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。
>
> 　　**可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。**也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。

#### 一段“看不见”的代码

```java
public class NoVisibility {
    // 告诉JVM flag是个善变的变量，需要我们盯住它
	static /*volatile*/ boolean flag;
	static int count = 0;
	
	private static class NoVisibilityThread extends Thread {
		@Override
		public void run() {
			System.out.println("进入线程run()");
			while (!flag) {}; // 死循环
			System.out.println(count);
		}
	}
	
	
	public static void main(String[] args) throws InterruptedException {
		new NoVisibilityThread().start();
		Thread.sleep(10); // 休眠10ms 保证在flag = true前进入循环
		count = 10;
		flag = true;
		Thread.sleep(10); // 休眠10ms 保证在执行完 flag = true 后进入线程时间片
		System.out.println("主线程执行完毕");
	}
}
```

### **有序性**

> `Java` 语言提供了 `volatile` 和 `synchronized` 两个关键字来保证线程之间操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，
>
> `synchronized` 是由“一个变量在同一个时刻只允许一条线程对其进行 *lock* 操作”这条规则获得的，此规则决定了持有同一个对象锁的两个同步块只能串行执行。

## synchronized 内置锁

### 使用方式

#### 修饰方法

```java
public synchronized void sayHello(){}
```

#### 修饰代码块

```java
public void sayHello() {
    synchronized(lock){
        System.out.println(hello);
    }
}
```

### 对象锁与类锁

- 对象锁

  使用`对象实例`作为锁；

- 类锁

  使用`Class对象实例`作为锁，即直接使用`synchronized`修饰方法

### 错误使用synchronized

```java
/**
 返回以对象内存地址计算得出hash值,可近似认为内存地址
 该方法可在Object中hashCode()方法重写后使用
*/
System.identityHashCode(object); 
```

#### 错误代码 - 基本类型包装类引发的线程错误

```java
/**
 * 类说明：错误的加锁和原因分析
 */
public class TestIntegerSyn {

    public static void main(String[] args) throws InterruptedException {
        Worker worker=new Worker(1);
        //Thread.sleep(50);
        for(int i=0;i<5;i++) {
            new Thread(worker).start();
        }
    }

    private static class Worker implements Runnable{

        private Integer i;
        // private Object o = new Object(); // 解决方法

        public Worker(Integer i) {
            this.i=i;
        }

        @Override
        public void run() {
            synchronized(i) {
            // synchronized (o) { //解决方法
                Thread thread=Thread.currentThread();
                System.out.println(thread.getName()+"--@"
                        +System.identityHashCode(i));
                i++; // 错误关键代码
                System.out.println(thread.getName()+"-------"+i+"-@"
                        +System.identityHashCode(i));
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println(thread.getName()+"-------"+i+"--@"
                        +System.identityHashCode(i));
            }

        }

    }

}
```

- 执行结果

```java
Thread-0--@7051476
Thread-0-------2-@246179497
Thread-0-------2--@246179497
Thread-4--@246179497
Thread-4-------3-@1913323607
Thread-4-------3--@1913323607
Thread-3--@1913323607
Thread-3-------4-@1518908764
Thread-3-------4--@1518908764
Thread-2--@1518908764
Thread-2-------5-@714548956
Thread-2-------5--@714548956
Thread-1--@714548956
Thread-1-------6-@731692489
Thread-1-------6--@731692489
```

很明显输出结果并未如我们预料般有序输出，其次注意对象内存地址发生变化。

- 错误原因

`Integer`源码 - 或通过反编译生成字节码查看实际运行代码

```java
public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
}
```

`Integet`导致每次将返回一个新对象，导致我们每次对不同的对象上锁，从而引发线程安全问题。

- 解决方法

```java
// Integer i;
Object o = new Object(); // 要求我们的'锁'不会发生变化
```

## volatile 最轻量同步机制

`volatile` 易变的, 无常的。保证`可见性`

- 百度

> **volatile**的作用是作为指令[关键字](https://baike.baidu.com/item/%E5%85%B3%E9%94%AE%E5%AD%97/7105697)，确保本条指令不会因[编译器](https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%99%A8/8853067)的优化而省略，且要求每次直接读值。

- [郑州的文武]

> 　　Java语言提供了一种稍弱的同步机制，即`volatile`变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为`volatile`类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。`volatile`变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取`volatile`类型的变量时总会返回最新写入的值。
>
> 　　在访问`volatile`变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此`volatile`变量是一种比`sychronized`关键字更轻量级的同步机制。
>
> ​	当对非 volatile 变量进行读写的时候，每个线程先从内存拷贝变量到`CPU缓存`中。如果计算机有多个`CPU`，每个线程可能在不同的`CPU`上被处理，这意味着每个线程可以拷贝到不同的`CPU cache`中。
>
> 　　而声明变量是 `volatile` 的，`JVM` 保证了每次读变量都从内存中读，跳过`CPU cache`这一步。

### 应用场景

一个线程写，多个线程读。这让我一下联想到`分布式数据库`中的`master-salve`

### 参考

https://baike.baidu.com/item/volatile/10606957?fr=aladdin

https://www.cnblogs.com/zhengbin/p/5654805.html

## ThreadLocal

在类中声明一个`static ThreadLocal<Integer> intLocal;`与`static int i;`。

其中**i**对于所有线程都是“平等”的；而**intLocal**则允许每个线程持有一个属于自己的Integer对象。

而ThreadLocal的实现思路就是实现Java线程的私有变量。

> 其非常适用于同一线程中，不同开发层次中共享数据。
>
> （from:https://www.cnblogs.com/listened/p/5031478.html）

### 与synchronized比较

`ThreadLocal`与`synchronized`均用于解决多线程并发访问。

- synchronized

  `synchronized`利用锁的机制，使变量和代码块在某一时刻仅能被一个线程访问；

- ThreadLocal

  `ThreadLocal`为每个线程提供了变量的副本，使得线程在某一时间访问的并非同一对象，以隔离多个线程对数据的数据共享；

### 应用场景

- Spring事务

  `Spring`将从连接池中获取一个`Connection`对象，然后将这个对象放入`ThreadLocal`与线程绑定。若`Spring`不使用`ThreadLocal`，在同一`Service`调用一些列`Dao`时，需要保证在这个`Service`中仅使用一个连接以满足在这个过程中对数据操作的一致性。

  且Web容器中，每个完整的请求周期由一个线程来处理。我们将变量(例如Connection对象)绑定到线程中，就能很好地实现软件架构中的跨层次参数共享（隐式共享）——ThreadLocal。

  结合Spring IOC与AOP，就能很好解决这一点。

### 使用方式

- void set(Object value)

- public Object get()

- public void remove()

  将当前线程局部变量删除，目的是为了减少内存占用，该方法为JDK5新增方法。同时线程结束后，对于该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程非必须操作，但它能加速内存回收速度。

- protected Object initialValue()

  返回该线程局部变量的初始值。该方法是一个protected方法，显然是为了让子类覆盖而设计。这个方法是一个延时调用的方法，在线程第一次调用get()或者set(Object value)时才执行，并且仅执行1次。ThreadLocal的缺省实现是返回一个null。

  ``` java
  protected T initialValue() {
      return null;
  }
  ```

``` java
/**
* resource为一个存放String的ThreadLocal对象，不论何时任一线程对它进行读写操作均为线程安全的。
*/
public final static ThreadLocal<String> resource = new Thread<String>()
```

#### 为何将ThreadLocal声明为静态变量

常常见人们将`ThreadLocal`声明为静态变量——static。

``` java
private static ThreadLocal<Integer> intVal = new ThreadLocal<>();
```

首先修改当前`WithThreadLocal.java`代码中的静态内部类`TestThread`

``` java
public static class TestThread implements Runnable{
		int id;
		int intLocal = 1;
		public TestThread(int id){
		    this.id = id;
		}
		public void run() {
		    System.out.println(Thread.currentThread().getName()+":start");
		    Integer s = intLocal;
		    s = s+id;
		    intLocal = s;
		    System.out.println(Thread.currentThread().getName()
		            +":"+ intLocal);
		    //intLocal.remove();
		}
	}

```

由于变量`int intLocal`属于线程私有，与`ThreadLocal`实现思想（见下）一致，所以运行结果一致。但这种声明方式仅能在`Thread`或`Runnable`派生类中使用，缺乏灵活度。

- 将`ThreadLocal`作为成员变量存在相同问题。

- `ThreadLocal`本身被设计为多线程直接调用即可，这种隐式的使用方法令开发过程更便利。
- 实际保存变量的是线程内部的`ThreadLocalMap`，`ThreadLocal`的更像是两者之间的桥梁（*工具类*）。使用**static**关键字声明减小了`JVM`内存开销。

### 实现解析

``` java
 /**
     * Returns the value in the current thread's copy of this
     * thread-local variable.  If the variable has no value for the
     * current thread, it is first initialized to the value returned
     * by an invocation of the {@link #initialValue} method.
     *
     * @return the current thread's value of this thread-local
     */
    public T get() {
        Thread t = Thread.currentThread(); // 获取当前线程
        ThreadLocalMap map = getMap(t);
        if (map != null) {
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) {
                @SuppressWarnings("unchecked")
                T result = (T)e.value;
                return result;
            }
        }
        return setInitialValue();
    }

/**
     * Get the map associated with a ThreadLocal. Overridden in
     * InheritableThreadLocal.
     *
     * @param  t the current thread
     * @return the map
     */
    ThreadLocalMap getMap(Thread t) {
        return t.threadLocals;
    }
    
```

其中`ThreadLocalMap`是`ThreadLocal`静态内部类。再通过`getMap(Thread t)`方法返回线程成员变量（线程私有）。

``` java
// Thread类源码
/* ThreadLocal values pertaining to this thread. This map is maintained
     * by the ThreadLocal class. */
    ThreadLocal.ThreadLocalMap threadLocals = null;
```

- ThreadLocalMap源码

![1560263676665](https://github.com/Houchengisnull/helloWorld/blob/master/documents/images/并发-java/1560263676665.png)

其持有一个Entry内部静态类，继承`WeakReference`，它记录了两个信息——ThreadLocal<?>与Object。getEntry方法则是获取某个ThreadLocal对应的值，set方法即更新或复制相应的ThreadLocal的值。

``` java
private Entry getEntry(ThreadLocal<?> key) {
    		// 以ThreadLocal为键值进行位运算
            int i = key.threadLocalHashCode & (table.length - 1);
            /* 
            	获取相应ThreadLocal对象的value
    		 	可参考HashMap源代码加深理解
    		 	当遇到重复hash时调用nextHashCode()方法以避免碰撞
    		*/
    		Entry e = table[i];
            if (e != null && e.get() == key)
                return e;
            else
                return getEntryAfterMiss(key, i, e);
        }
```

![1560265052378](https://github.com/Houchengisnull/helloWorld/blob/master/documents/images/并发-java/1560265052378.png)

所以在调用ThreadLocal对象get方法时，实际现获取当前线程独有的`ThreadLocalMap`，再以ThreadLocal当前实例作为键值拿到Map中相应的Entry。

ThreadLocal是Java编写者对内部类应用的绝佳的演示。

### 内存泄漏问题

#### Java中的各种引用

##### 强引用

强引用在程序代码中普遍存在。只要强引用还存在，`垃圾回收器`便永远不会回收被引用的对象实例。

``` java
Object obj = new Object();
```

##### 软引用

描述一些有用但非必需的对象。

在`JVM`将发生内存溢出前，将回收这些`软引用`指向的对象实例。如果此次回收之后依然没有足够的内存，才会抛出内存溢出异常。

`JDK1.2`提供`SoftReference`来实现软引用。

> - 内存溢出
>
>   程序申请内存时，没有足够的内存空间供其使用，出现`Out of Memory`。
>
> - 内存泄漏
>
>   程序在申请内存后，无法释放已申请的内存空间。一次内存泄露危害可以忽略，但内存泄漏堆积后果很严重。将会导致`Out of Memory`。

https://www.cnblogs.com/panxuejun/p/5883044.html

##### 弱引用

只要发生`垃圾回收`，无论当前内存是否足够，`弱引用`一定被回收。

`JDK1.2`提供`WeakReference`类来实现弱引用。

##### 虚引用

幽灵引用或幻影引用。它是最虚的一种引用，一个对象实例是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。

- 虚引用唯一的应用场景

  能令对象在被垃圾回收时收到一个系统通知。

JDK1.2`提供`WeakReference`类来实现弱引用。