[toc]

# 使用线程池的原因

- **降低资源消耗**	通过重复利用已创建的线程池，降低线程创建和销毁造成的消耗。

- **提高响应速度**	

  服务器完成一项任务的耗时：T1创建线程时间 + T2执行任务时间 + T3销毁线程时间。

  如果T1 + T3 >> T2，则可以使用线程池，减少(T1 + T3)，以提高服务器性能。

  我们可以将T1与T3安排在服务器启动和结束的时间段或者一些空闲的时间，这样服务器程序处理客户请求时就不会有T1与T3的开销了。

- **提高线程的可管理性**	

  线程是一种稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性。

  使用线程池可以进行`统一分配`、`调优`和`监控`。

# ThreadPoolExecutor

![executor](../images/并发-java/executor.png)

## Executor

`Executor`框架基础。其中只有一个`execute`方法，负责将任务交给线程池中的线程执行。

``` java
void execute(Runnable command);
```

## ExecutorService

接口继承了`Executor`。在其基础上添加管理线程池的方法。

- **shutdown()**	中断已经执行完任务的线程，且并不再接受新任务

- **shutdownNow()**	试图中断所有线程，不论是否在执行任务

- **isShutdown()**	当调用`shutdown()|shutdownNow()`后，返回`true`

- **isTerminated()**	

  线程池成功停止后返回`true`

- **awaitTermination(Long, TimeUnit)**

  阻塞调用线程池的线程，有以下三种情况将唤醒当前线程：

  1. 等待超时
  2. 线程池中所有任务执行完毕
  3. 当前线程被中断

- **submit(Callable)**

- **submit(Runnable, T)**

- **submit(Runnable)**

- **invokeAll(Collection<? extends Callable<T>>)**

  执行任务集合，等待所有任务完成后同一返回（阻塞）。

- **invokeAny(Collection<? extends Callable<T>>)**

  执行任务集合，将第一个完成的任务作为结果返回，并停止其他任务的执行。

## AbstractExecutorService

其实现了`ExecutorService`的大部分方法。

## ThreadPoolExecutor

线程池核心实现类

## ScheduledExecutorService

该接口继承了`ExecutorService`，用于实现**定时**功能的线程池。

### ScheduledThreadPoolExecutor

`ScheduledExecutorService`的实现类。

- 与`Timer`相比

  