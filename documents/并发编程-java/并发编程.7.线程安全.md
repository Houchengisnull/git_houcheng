[toc]

# (类)线程安全定义

> 《Java并发编程实战》:
>
> ​	当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在调用代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

## 线程封闭

优雅地并发编程是困难的，所以很多时候，我们希望可以**避免并发**。

**避免并发**最简单的方式就是`线程封闭`，而`线程封闭`就是把对象封装到一个线程里。

- **线程封闭的方式**

  - **ad-hoc**	完全依靠实现者控制的线程封闭。

  - **栈封闭**

    这是在`Java`并发编程中最常用的`线程封闭`。由`线程栈`为`线程私有`保证，即使用局部变量。

  > `ThreadLocal`是线程封闭的一种**最好**方式。
  >
  > `ThreadLocal`内部维护`Map`，`key`是线程名称， `value`是我们封闭的对象，从而实现线程与对象的绑定。

## 无状态的类

(在面向对象中)，类的状态指类的成员变量，而`无状态的类`即没有成员变量的类。

## 让类(状态)不可变

- **让类不可变的方式**

  - **final**

  首先使用`final`关键字修饰成员变量，再**安全发布**该对象；

  - 不提供任何修改或返回该成员变量的方法；

## volatile

保证类的可见性。

## 加锁与CAS

- <a href='https://github.com/Houchengisnull/helloWorld/blob/master/documents/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.4.CAS.md'>并发编程.4.CAS.md</a>
- <a href='https://github.com/Houchengisnull/helloWorld/blob/master/documents/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.5.AQS%E4%B8%8E%E6%98%BE%E5%BC%8F%E9%94%81.md'>并发编程.5.AQS与显式锁.md</a>

## 安全发布

- **发布**	让外界发布看到类的成员变量

对于`基本数据类型`的发布，是安全的；但对于`引用数据类型`的发布，直接发布是不安全的。我们在实现的时候需要考虑线程安全问题。

# 死锁

## 概念

- **必要条件**
- 多个操作者
- 多个资源
- 获取资源顺序不对

### 学术化定义

死锁的发送必须具备以下四个**必要**条件：

- **互斥条件**

  `调度者`(进程|线程)所申请的资源具有排它性，即在一段时间内某资源只由一个`调度者`占用。

- **请求和保持条件**

  `调度者`需要占用一个以上的`资源`。

  当`调度者`已经占据了一个`资源`，在申请`新资源`时，而该`资源`被其他`调度者`占据，因此进入阻塞状态。

- **不剥夺条件**

  `调度者`在完成任务前不释放`已有资源`。

- **环路等待条件**

  `调度者们`互相持有资源互相等待。

<hr>

为避免、预防和解除死锁，我们需要打破四个必要条件的任意一个即可。

- **打破互斥条件**

  改造独占性资源为虚拟资源。

- **打破占有且申请条件**

  采用`资源预先分配策略`，即程序运行前申请所有资源，满足则运行，否则等待。

- **打破不可抢占条件**

  当无法获取所有`资源`时，`调度者`释放已有`资源`。

- **打破循环等待条件**

  采用`资源有序分配策略`，对`调度者`分配编号，按照序号递增申请资源。

> 避免死锁常见算法：有序资源分配法，银行家算法等。

## 现象、危害和解决

在数据库多事务且同时操作多个表的情况下，常有死锁现象发生。

所以数据库在设计时，预先考虑了`检测死锁`和`从死锁中恢复`的机制。

比如`oracle`提供了检测和处理死锁的语句：

``` sql
/**
* 使用dba用户只需该statement以检测死锁
* 
* username 死锁语句所使用的数据库用户
* lockwait 死锁的状态,如果有内容表示被死锁
* status 状态, active表示被死锁
* machine 死锁语句所在机器
* program 死锁语句来自哪个程序
*/
SELECT 
	username
	, lockwait
	, status
	, machine
	, program 
FROM v$session
WHERE sid IN (
		SELECT session_id
    	FROM v$locked_object
	);
	
/**
* 使用dba用户只需该statement以检测死锁语句
*/
SELECT sql_text
FROM v$sql
WHERE hash_value IN (
    SELECT sql_hash_value 
    FROM v$session 
    WHERE sid IN (		
		SELECT session_id
		FROM v$locked_object
	) 
);

/*
* 查找死锁进程
*/
SELECT 
	s.username
	, l.object_id
	, l.session_id
	, s.serial#
	, l.oracle_username
	, l.os_user_name
	, l.process
FROM v$locked_object l, v$session s
WHERE l.session = s.sid;

/**
* kill掉进程
*/
/*
* 使用sysdba用户kill
* sqlplus "/as sysdba" 
*/
alter system kill session 'sid, serial#';
```

<hr>

而`mysql`提供了`循环依赖检测机制`：

``` sql
# 查看当前事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;
# 查看当前锁定事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;
# 查看当前等锁的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
# 杀死线程id
kill $pid
```

发送死锁时，`mysql`将频繁报错。

> Deadlock found when trying to get to lock; try restarting transaction.

### 现象

- **简单顺序死锁**

- **动态顺序死锁**

  

### 危害

- 进程存活，线程未能正常工作
- 无异常信息
- 只有重启程序才能解决问题

### 解决

#### 定位

#### 修正

# 其他安全问题

## 活锁

## 线程饥饿

# 并发下的性能

## 基本原则

## 线程引入的开销

### 上下文切换

### 内存同步

### 阻塞

# 如何减少锁的竞争

## 减少锁的粒度

## 缩小锁的范围

## 避免多余的锁

## 锁分段

## 替换独占锁

