[toc]

# (类)线程安全定义

> 《Java并发编程实战》:
>
> ​	当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在调用代码中不需要任何额外的同步或者协同，这个类都能表现出正确的行为，那么就称这个类是线程安全的。

## 线程封闭

优雅地并发编程是困难的，所以很多时候，我们希望可以**避免并发**。

**避免并发**最简单的方式就是`线程封闭`，而`线程封闭`就是把对象封装到一个线程里。

- **线程封闭的方式**

  - **ad-hoc**	完全依靠实现者控制的线程封闭。

  - **栈封闭**

    这是在`Java`并发编程中最常用的`线程封闭`。由`线程栈`为`线程私有`保证，即使用局部变量。

  > `ThreadLocal`是线程封闭的一种**最好**方式。
  >
  > `ThreadLocal`内部维护`Map`，`key`是线程名称， `value`是我们封闭的对象，从而实现线程与对象的绑定。

## 无状态的类

(在面向对象中)，类的状态指类的成员变量，而`无状态的类`即没有成员变量的类。

## 让类(状态)不可变

- **让类不可变的方式**

  - **final**

  首先使用`final`关键字修饰成员变量，再**安全发布**该对象；

  - 不提供任何修改或返回该成员变量的方法；

## volatile

保证类的可见性。

## 加锁与CAS

- <a href='https://github.com/Houchengisnull/helloWorld/blob/master/documents/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.4.CAS.md'>并发编程.4.CAS.md</a>
- <a href='https://github.com/Houchengisnull/helloWorld/blob/master/documents/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-java/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B.5.AQS%E4%B8%8E%E6%98%BE%E5%BC%8F%E9%94%81.md'>并发编程.5.AQS与显式锁.md</a>

## 安全发布

- **发布**	让外界发布看到类的成员变量

对于`基本数据类型`的发布，是安全的；但对于`引用数据类型`的发布，直接发布是不安全的。我们在实现的时候需要考虑线程安全问题。

# 死锁

## 概念

- **必要条件**
- 多个操作者
- 多个资源
- 获取资源顺序不对

### 学术化定义

死锁的发送必须具备以下四个**必要**条件：

- **互斥条件**

  `调度者`(进程|线程)所申请的资源具有排它性，即在一段时间内某资源只由一个`调度者`占用。

- **请求和保持条件**

  `调度者`需要占用一个以上的`资源`。

  当`调度者`已经占据了一个`资源`，在申请`新资源`时，而该`资源`被其他`调度者`占据，因此进入阻塞状态。

- **不剥夺条件**

  `调度者`在完成任务前不释放`已有资源`。

- **环路等待条件**

  `调度者们`互相持有资源互相等待。

<hr>

为避免、预防和解除死锁，我们需要打破四个必要条件的任意一个即可。

- **打破互斥条件**

  改造独占性资源为虚拟资源。

- **打破占有且申请条件**

  采用`资源预先分配策略`，即程序运行前申请所有资源，满足则运行，否则等待。

- **打破不可抢占条件**

  当无法获取所有`资源`时，`调度者`释放已有`资源`。

- **打破循环等待条件**

  采用`资源有序分配策略`，对`调度者`分配编号，按照序号递增申请资源。

> 避免死锁常见算法：有序资源分配法，银行家算法等。

## 现象、危害和解决

在数据库多事务且同时操作多个表的情况下，常有死锁现象发生。

所以数据库在设计时，预先考虑了`检测死锁`和`从死锁中恢复`的机制。

比如`oracle`提供了检测和处理死锁的语句：

``` sql
/**
* 使用dba用户只需该statement以检测死锁
* 
* username 死锁语句所使用的数据库用户
* lockwait 死锁的状态,如果有内容表示被死锁
* status 状态, active表示被死锁
* machine 死锁语句所在机器
* program 死锁语句来自哪个程序
*/
SELECT 
	username
	, lockwait
	, status
	, machine
	, program 
FROM v$session
WHERE sid IN (
		SELECT session_id
    	FROM v$locked_object
	);
	
/**
* 使用dba用户只需该statement以检测死锁语句
*/
SELECT sql_text
FROM v$sql
WHERE hash_value IN (
    SELECT sql_hash_value 
    FROM v$session 
    WHERE sid IN (		
		SELECT session_id
		FROM v$locked_object
	) 
);

/*
* 查找死锁进程
*/
SELECT 
	s.username
	, l.object_id
	, l.session_id
	, s.serial#
	, l.oracle_username
	, l.os_user_name
	, l.process
FROM v$locked_object l, v$session s
WHERE l.session = s.sid;

/**
* kill掉进程
*/
/*
* 使用sysdba用户kill
* sqlplus "/as sysdba" 
*/
alter system kill session 'sid, serial#';
```

<hr>

而`mysql`提供了`循环依赖检测机制`：

``` sql
# 查看当前事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;
# 查看当前锁定事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCKS;
# 查看当前等锁的事务
SELECT * FROM INFORMATION_SCHEMA.INNODB_LOCK_WAITS;
# 杀死线程id
kill $pid
```

发送死锁时，`mysql`将频繁报错。

> Deadlock found when trying to get to lock; try restarting transaction.

- **现象**
- 简单顺序死锁
- 动态顺序死锁

<hr>

- **危害**

- 进程存活，线程未能正常工作
- 无异常信息
- 只有重启程序才能解决问题

<hr>

- **解决**

- **定位**

  1. 通过`jps`工具查询应用`id`；
  2. 再通过`jstack $pid`查看应用持有锁的情况；

  > 在使用`IntelliJ IDEA `时，可通过在控制台的📷按钮(`thread dump`)，查看线程堆栈与锁的情况。

- **修正**

  1. 内部通过顺序比较，确定申请锁的顺序；
  2. 采用尝试获取锁的机制——`tryLock()`；

> - `Dump`
>
> 中文释义：转储。
>
> 程序在计算机中奔跑时，在内存、CPU、I/O设备上的数据是动态的，如果需要得到某些时刻的数据，比如debug时的信息，就需要把这些信息**dump**为静态的（持久的）数据。
>
> 此外常用的工具还有`Unix/Linux`中的`coredump`、`Java`中的`headdump`和`threaddump`，以及`tcpdump`。
>
> <a href='https://www.zhihu.com/question/285731828/answer/455335550'>计算机术语dump是什么意思？</a>

# 其他安全问题

## 活锁

两个线程在`尝试获取锁机制`中，发送多个线程互相谦让，不断发生**同一个线程总是拿到同一把锁，在尝试获取其他锁时失败，再释放已持有锁**的情况。

针对这种情况，我们在线程释放锁后，令当前线程休眠随机时长，以错开申请锁的时间。

## 线程饥饿

低优先级的线程，总是无法获取执行时间。

# 并发下的性能

使用并发的目标是为了提高性能。但引入多线程后，其实会引入额外的开销——比如线程之间的协调，上下文切换，线程的创建与销毁，线程的调度等等。

过度的使用与不恰当的使用，会导致多线程程序运行效率比单线程还要低。

## 基本原则

- 先保证程序正确运行
- 运行效率是否达标以测试人员为基准

> - `过早优化效应(Premature Optimization Effect)`。
>
>   高德纳在《goto语句的结构化编程》论文中提及：“过早优化是万恶之源。”

## 线程引入的开销

### 上下文切换

操作系统将正在运行的线程调度出来，从而使其他线程能够使用`CPU`的过程，称之为`上下文切换`。

首先，当前操作系统将**保存**当前线程的`执行上下文`，

其次，将新调度进来的线程的`执行上下文`**设置**为`当前上下文`。

<u>就像我们在同时阅读几本书，在来回切换书本时记录每本书当前阅读的页码。</u>

<hr>

`切换上下文`需要一定的开销。

在线程调度过程中需要访问由操作系统和`JVM`共享的数据结构。`JVM`与操作系统的代码中消耗越多的`CPU时钟周期`，应用程序的`可用CPU`时钟周期就越少。

当线程频繁发生阻塞，`CPU密集型程序`便会发生越多的上下文切换，从而增加调度开销，并因此降低吞吐量。

所以，在设置`CPU密集型程序`的线程池的大小时，核心线程数越少越好——n`CPU`+1。

`切换上下文`是一个计算密集型操作，它需要相当的处理器时间。大多数处理器上下文切换的开销相当于50~10000个时钟周期，大概是几微秒。

<hr>

> - **vmstat**
>
> `vmstat`可以报告上下文切换次数以及在内核中执行时间所占比例等信息。如果内核占用率较高（>10%)通常表示调度活动发送得很频繁，这可能是由IO或者锁竞争导致的阻塞引起的。

### 内存同步

在`synchronized`和`volatile`提供的可见性保证中，可能会使用一些特殊指令，比如`内存栅栏（Memory Barrier）`。

内存栅栏将刷新缓存，使缓存无效刷新硬件的写缓存，以及停止执行管道。

内存栅栏同样会对性能带来影响，这将抑制一些编译器的优化操作。

**在内存栅栏中，大多数操作都是不能被重排序的。**

### 阻塞

`阻塞`会将线程挂起。

`挂起进程`在操作系统中，可以被定义为：暂时被淘汰出内存的进程。

在机器资源不足时，操作系统对在内存中的程序进行合理安排，部分进程被暂时调离出内存，当条件允许是，被操作系统再次调回内存。

重新进入等待被执行的状态被称为就绪状态，系统在超过一定的时间内没有任何动作。

显而易见，这个操作将执行至少两次上下文切换。

# 如何减少锁的竞争

## 减少锁的粒度

使用锁的时候，锁保护对象是多个。但当这些多个对象是独立变化的模块，可以使用多个锁来一一保护这些对象。

## 缩小锁的范围——锁细化

对锁的持有实现**快进快出**，尽量缩短持有锁的时间。将一些<u>不需要锁的代码</u>移出同步代码块。特别是针对那些耗时或者阻塞地操作。

> 大概是锁的范围应该有个区间，不宜太大或太小。

## 避免多余的锁

两次加锁直接的语句非常简单，导致加锁的时间比执行时间还要长，这个时候应该进行锁的粗话——扩大锁的范围。

> 个人认为应该考虑自旋锁等轻量级锁才对。

## 锁分段

`ConcurrentHashMap`就是典型的锁分段。

## 替换独占锁

在业务允许情况下

- 使用读写锁——锁的分离

- 使用自旋锁——CAS

- 使用系统的并发容器

  关于这一点，自己实现的轻量的同步代码运行效率可能优于`JDK`的并发容器，应该三思~。