[toc]

# 显式锁

- 什么是显式锁

使用 synchronized 关键字时，线程隐式地获取锁。

而与之相对应的则是显式锁——Lock。

## Lock的特性

有了`synchronized`为什么还需要`Lock`？

`synchronized`固定了线程对锁获取与释放的过程，有时候我们需要更灵活地获取与释放锁，这时候就需要Lock。

- 尝试非阻塞地获取锁

  使用`lock.tryLock()`。

  使用`synchronized`时，直至线程获取锁，否则一直处于阻塞状态。

- 能被中断地获取锁

  使用`lock.lockInterruptibly()`。

  当线程处于阻塞状态时不可被中断。

- 超时获取锁

### synchronized与Lock区别

- `synchronized`是`java`关键字，`Lock`是`java`接口；
- `synchronized`不需要用户手动释放锁，`Lock`需要用户手动释放锁，否则可能导致死锁现象；
- `synchronized`是不可中断锁，`Lock`是可中断锁；
- `synchronized`未非公平锁，`Lock`默认情况下为非公平锁，但可设置公平锁；
- `Lock`可返回是否获得锁；
- `Lock`可设置等待锁时间；
- `synchronized`消耗更小，所以在一般情况使用`synchronized`

## Lock标准用法

``` java
lock.lock()
try {
    count++
} catch (Exception e) {
    
} finally {
    // 无论是否存在异常均要释放锁
    lock.unlock();
}
```

> 不要将`lock.lock()`写在`try代码块`中，因为如果在获取锁的过程时发生了异常，异常在抛出同时，将导致锁的无故释放。

## 常用`API`

| method                                                       | description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `void lock()`                                                | 获取锁                                                       |
| `void lockInteerruptibly() throws InterruptedException`      | 可中断地获取锁                                               |
| `boolean tryLock()`                                          | 非阻塞地获取锁                                               |
| `boolean tryLock(long time, TimeUnit unit) throws InterruptedException` | 当前线程在超时时间内获取锁、超时间内被中断和超时时间结束（返回false）三种情况下将返回 |
| `void unlock()`                                              | 释放锁                                                       |

- 通过`tryLock`来获取锁

  ``` java
  Lock lock = new ReentrantLock();
  if (lock.tryLock()) {
      try {
          // 处理任务
      } catch(Exception ex) {
          
      } finally{
          lock.unlock(); // 释放锁
      }
  } else {
      // 如果不能获得锁，则处理其他任务
  }
  ```

## `ReentranLock`

