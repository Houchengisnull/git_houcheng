[toc]

# 显式锁

- 什么是显式锁

使用 synchronized 关键字时，线程隐式地获取锁。

而与之相对应的则是显式锁——Lock。

> 当一个线程死亡时，其持有所有线程将释放。

## Lock的特性

有了`synchronized`为什么还需要`Lock`？

`synchronized`固定了线程对锁获取与释放的过程，有时候我们需要更灵活地获取与释放锁，这时候就需要Lock。

- 尝试非阻塞地获取锁

  使用`lock.tryLock()`。

  使用`synchronized`时，直至线程获取锁，否则一直处于阻塞状态。

- 能被中断地获取锁

  使用`lock.lockInterruptibly()`。

  当线程处于阻塞状态时不可被中断。

- 超时获取锁

## Lock与synchronized区别

- `synchronized`是`java`关键字，`Lock`是`java`接口；
- `synchronized`不需要用户手动释放锁，`Lock`需要用户手动释放锁，否则可能导致死锁现象；
- `synchronized`为隐式锁，`Lock`为显式锁；
- `synchronized`是不可中断锁，`Lock`是可中断锁；
- `synchronized`未非公平锁，`Lock`默认情况下为非公平锁，但可设置公平锁；
- `Lock`可返回是否获得锁；
- `Lock`可设置等待锁时间；
- `synchronized`消耗更小，所以在一般情况使用`synchronized`

## Lock标准用法

``` java
lock.lock()
try {
    count++
} catch (Exception e) {
    
} finally {
    // 无论是否存在异常均要释放锁
    lock.unlock();
}
```

> 不要将`lock.lock()`写在`try代码块`中，因为如果在获取锁的过程时发生了异常，异常在抛出同时，将导致锁的无故释放。

## 常用`API`

| method                                                       | description                                                  |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| `void lock()`                                                | 获取锁                                                       |
| `void lockInteerruptibly() throws InterruptedException`      | 可中断地获取锁                                               |
| `boolean tryLock()`                                          | 非阻塞地获取锁                                               |
| `boolean tryLock(long time, TimeUnit unit) throws InterruptedException` | 当前线程在超时时间内获取锁、超时间内被中断和超时时间结束（返回false）三种情况下将返回 |
| `void unlock()`                                              | 释放锁                                                       |

- 通过`tryLock`来获取锁

  ``` java
  Lock lock = new ReentrantLock();
  if (lock.tryLock()) {
      try {
          // 处理任务
      } catch(Exception ex) {
          
      } finally{
          lock.unlock(); // 释放锁
      }
  } else {
      // 如果不能获得锁，则处理其他任务
  }
  ```

# 可重入锁`ReentrantLock`

## 什么是可重入锁

一个线程对于已经获得的锁，可以多次继续申请到该锁的使用权。

- `synchronized`与`ReentrantLock`均为可重入锁

  `synchronized`隐式支持可重入，例如`synchronized`修饰递归方法，在方法执行时，执行线程在获取了锁之后仍然连续多次地获得该锁。

  `ReentrantLock`在调用`lock()`时，已经获取到锁地线程，能够再次调用`lock()`获取锁而不被阻塞。

## 公平锁与非公平锁

如果线程获取锁的顺序，根据对锁请求的时间先后来计算，那么这个锁是公平锁。

- `ReentrantLock`默认为非公平锁

  `public ReentrantLock(boolean fair)`

  ``` java
  // 令ReentrantLock为公平锁
  Lock lock = new ReentrantLock(true);
  ```

- 公平锁效率没有非公平锁高。

  这是因为**恢复一个挂起的线程与该线程真正开始运行之间存在严重的延迟**。

  > CPU上下文切换需要约5000~10000 CPU时间周期。

  假设线程A持有一个锁，并且线程B请求这个锁。

  由于这个锁已被线程A持有，因此B将被挂起。当A释放锁时,B 将被唤醒，因此会再次尝试获取锁。

  与此同时，如果C也请求这个锁，那么C很可能会在B被完全唤醒之前获得、使用以及释放这个锁。这样的情况是一种"双赢"的局面：B获得锁的时刻并没有推迟，C更早地获得了锁,并且**吞吐量也获得了提高**。

# 读写锁`ReentrantReadWriteLock`

``` java
/**
* ReentrantReadWriteLock并没有实现Lock接口
* ReadWriteLock也并不是Lock的子类
*/
public class ReentrantReadWriteLock
        implements ReadWriteLock, java.io.Serializable
```

互联网中有很多**读多写少**的场景。

例如在数据库领域，存在读多写少的情况，我们常常做读写分离。

人们将读写分离的思想应用于多线程领域，于是有了读写锁（`ReentrantReadWriteLock`）。

读写锁维护了一对锁——读锁和写锁，通过分离了读锁和写锁在保证线程安全的同时，提高了并发性。

- 读锁——共享锁

  在同一时刻允许多个线程持有共享锁，但排斥写锁。

- 写锁——排他锁

  在同一时刻仅允许一个线程访问，其他线程均被阻塞。

> 排他锁又称独占锁。

此外，读写锁简化了读写交互场景的编程方式。

## 代码应用

- 商品

  ``` java
  /**
   *类说明：商品的实体类
   */
  public class GoodsInfo {
      private final String name;
      private double totalMoney;//总销售额
      private int storeNumber;//库存数
  
      public GoodsInfo(String name, int totalMoney, int storeNumber) {
          this.name = name;
          this.totalMoney = totalMoney;
          this.storeNumber = storeNumber;
      }
  
      public double getTotalMoney() {
          return totalMoney;
      }
  
      public int getStoreNumber() {
          return storeNumber;
      }
  
      public void changeNumber(int sellNumber){
          this.totalMoney += sellNumber*25;
          this.storeNumber -= sellNumber;
      }
  }
  
  ```

- 商品服务接口

  ``` java
  /**
   *类说明：商品的服务的接口
   */
  public interface GoodsService {
  
  	public GoodsInfo getNum() throws InterruptedException;//获得商品的信息
  	public void setNum(int number) throws InterruptedException;//设置商品的数量
  }
  ```

- 使用`synchronized`实现接口

  ``` java
  import java.util.concurrent.TimeUnit;
  
  /**
   *类说明：用内置锁来实现商品服务接口
   */
  public class UseSyn implements GoodsService {
  	
  	private GoodsInfo goodsInfo;
  	
  	public UseSyn(GoodsInfo goodsInfo) {
  		this.goodsInfo = goodsInfo;
  	}
  
  	@Override
  	public synchronized GoodsInfo getNum() throws InterruptedException {
  		TimeUnit.MICROSECONDS.sleep(5);
  		return this.goodsInfo;
  	}
  
  	@Override
  	public synchronized void setNum(int number) throws InterruptedException {
  		TimeUnit.MICROSECONDS.sleep(5);
  		goodsInfo.changeNumber(number);
  
  	}
  
  }
  
  ```

- 使用`ReentrantReadWriteLock`

  ``` java
  package org.hc.learning.thread.lock.readwrite;
  
  import java.util.concurrent.TimeUnit;
  import java.util.concurrent.locks.Lock;
  import java.util.concurrent.locks.ReadWriteLock;
  import java.util.concurrent.locks.ReentrantReadWriteLock;
  
  /**
   * 类说明：
   */
  public class UseRwLock  implements GoodsService{
  
      private GoodsInfo goodsInfo;
  
      private final ReadWriteLock lock = new ReentrantReadWriteLock();
      private final Lock getLock = lock.readLock();//读锁
      private final Lock setLock = lock.writeLock();//写锁
  
      public UseRwLock(GoodsInfo goodsInfo) {
          this.goodsInfo = goodsInfo;
      }
  
      @Override
      public GoodsInfo getNum() throws InterruptedException {
          getLock.lock();
          try{
              TimeUnit.MICROSECONDS.sleep(5);
              return this.goodsInfo;
          } finally {
              getLock.unlock();
          }
      }
  
      @Override
      public void setNum(int number) {
          setLock.lock();
          try{
              TimeUnit.MICROSECONDS.sleep(5);
              goodsInfo.changeNumber(number);
          } catch (InterruptedException e) {
              e.printStackTrace();
          } finally {
              setLock.unlock();
          }
      }
  }
  ```

- Main类

  ``` java
  import java.util.Random;
  import java.util.concurrent.TimeUnit;
  
  /**
   *类说明：对商品进行业务的应用
   */
  public class BusiApp {
      static final int readWriteRatio = 10;//读写线程的比例
      static final int minthreadCount = 3;//最少线程数
      //读操作
      private static class GetThread implements Runnable{
  
          private GoodsService goodsService;
          public GetThread(GoodsService goodsService) {
              this.goodsService = goodsService;
          }
  
          @Override
          public void run() {
              long start = System.currentTimeMillis();
              for(int i=0;i<100;i++){//操作100次
                  try {
                      goodsService.getNum();
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              }
              System.out.println(Thread.currentThread().getName()+"读取商品数据耗时："
               +(System.currentTimeMillis()-start)+"ms");
  
          }
      }
  
      //写操做
      private static class SetThread implements Runnable{
  
          private GoodsService goodsService;
          public SetThread(GoodsService goodsService) {
              this.goodsService = goodsService;
          }
  
          @Override
          public void run() {
              long start = System.currentTimeMillis();
              Random r = new Random();
              for(int i=0;i<10;i++){//操作10次
                  try {
                      TimeUnit.MICROSECONDS.sleep(5);
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
                  try {
                      goodsService.setNum(r.nextInt(10));
                  } catch (InterruptedException e) {
                      e.printStackTrace();
                  }
              }
              System.out.println(Thread.currentThread().getName()
              		+"写商品数据耗时："+(System.currentTimeMillis()-start)+"ms---------");
  
          }
      }
  
      public static void main(String[] args) throws InterruptedException {
          GoodsInfo goodsInfo = new GoodsInfo("Cup",100000,10000);
          GoodsService goodsService = new UseSyn(goodsInfo);
          /*GoodsService goodsService = new UseRwLock(goodsInfo);*/
          for(int i = 0;i<minthreadCount;i++){
              Thread setT = new Thread(new SetThread(goodsService));
              for(int j=0;j<readWriteRatio;j++) {
                  Thread getT = new Thread(new GetThread(goodsService));
                  getT.start();           	
              }
              Thread.sleep(5);
              setT.start();
          }
      }
  }
  ```

  能明显感受出使用`synchronized`和读写锁在解决该问题时效率上的区别。

# `Condition`接口

使用显式锁实现等待通知模型。

## API

- Lock

  ``` java
  public class ReentrantLock implements Lock, java.io.Serializable {
      
      ...
      /*
      * 返回一个Condition对象
      */
  	public Condition newCondition() {
          return sync.newCondition();
      }
      
      ...
  }
  ```

- Condition

  | method                          | explain                                                      |
  | ------------------------------- | ------------------------------------------------------------ |
  | `void await()`                  | 作用类似`Object`的`wait()`。当前线程进入等待状态直到被通知或中断。 |
  | `void awaitUninterruptibly()`   | 当前线程进入等待状态直到被通知。对中断不敏感。               |
  | `long awaitNanos(long)`         | 当前线程进入等待状态直到被通知、中断或超时。返回值表示剩余时间。 |
  | `boolean await(long, TimeUnit)` |                                                              |
  | `boolean awaitUntil(Date)`      | 当前线程进入等待状态直到被通知、中断或到某个时间。如果没有到指定时间就被通知，方法返回true。 |
  | `void signal()`                 | 作用类似`Object`的`notify()`。唤醒一个等待在`Condition`上的线程，该线程从等待方法返回且必须获得**与Condition相关联**的锁 |
  | `void signalAll()`              | 作用类似`Object`的`notifyAll()`                              |

## `Condition`使用范式

``` java
Lock lock = new ReentrantLock();
Condition condition = lock.newCondition();

public void conditionWait() throws InterruptedException {
    lock.lock();
    try{
        condition.await();
    } finally {
        lock.unlock();
    }
}

public void conditionSignal() throws InterruptedException {
    lock.lock();
    try {
        condition.signal();
    } finally {
        lock.unlock();
    }
}
```

# LockSupport并发工具类

`LockSupport`定义了一组的公共静态方法，这些方法提供了最基本的线程阻塞和唤醒功能，而`LockSupport`也成为构建同步组件的基础工具。

`LockSupport`定义了一组以`part*`命名的方法来阻塞线程，以及以`unpart*(Thread thread)`方法来唤醒一个被阻塞的线程。

`LockSupport`增加了

- `park(Object blocker)`
- `parkNanos(Object block, long nanos)`
- `parkUntil(Object blocker, long deadline)`

用于阻塞当前线程的功能，其中参数`blocker`是用来表示当前线程在等待的对象(阻塞对象)，该对象主要用于问题排查和系统监控。

- **park：**停车

> 最初仅`park()`与`unpark()`两个无参方法，造成程序员在调试时，无法得知当前线程。
>
> 于是在`JDK1.6`后增加带参方法。

# CLH队列锁

`Craig, Landin, and Hagersten locks`

- **目的** 解决多个线程竞争锁

CLH队列锁是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。

其中每个结点包含两个域

- **myPred：** 指向前驱结点的`locked`
- **locked：** 如果为`true`表示需要获取锁
- **tail：** 始终指向最后加入的线程/结点

`myPred`将不断自旋检测前驱结点`locked`，当`locked`为`false`时，表明前驱结点所代表的线程将锁释放，同时回收前驱结点。

## 优点

CLH队列锁的优点是空间复杂度低。

如果有n个线程，L个锁，每个线程每 次只获取一个锁，那么需要的存储空间是 O(L+n)，n个线程有n个node，L个锁有L个tail。 

`AQS`是CLH队列锁的变体实现。

## 扩展：SMP体系架构

CLH队列锁常用于`SMP体系架构`下。

> SMP(SymmetricMulti-Processor) 。即对称多处理器结构 ，指 server中多个CPU对称工作，每一个CPU访问内存地址所需时间相同。其主要特征是共享，包括对CPU，内存，I/O等进行共享。SMP的长处是可以保证内存一致性。缺点是这些共享的资源非常可能成为性能瓶颈。随着CPU数量的添加，每一个CPU都要访问同样的内存资源，可能导致内存问冲突，可能会导致CPU资源的浪费。经常使用的PC机就属于这样的。
>
> 非一致存储访问，将CPU分为CPU模块，每个CPU模块由多个CPU组成，并且具有独立的本地内存、I/O槽口等，模块之间可以通过互联模块相互访问，访问本地内存（本CPU模块的内存 ）的速度将远远高于访问远地内存 ( 其他CPU模块的内存)的速度，这也是非一致存储访问的由来。NUMA较好地解决SMP的扩展问题，当CPU数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。
>
> CLH唯一的缺点是NUMA系统结构下性能很差，但是在SMP系统结构下该法还是非常有效的。解决NUMA系统结构的思路是MCS队列锁 。

# AQS(`AbstractQueuedSynchronizer`)

队列同步器

## AQS的重要性

AQS是用来构建锁或者其他同步组件的基础框架。

- CountDownLatch
- ThreadPoolExecutor
- SelfLock
- ReentrantLock
- TrinityLock
- ReenterSelfLock
- ReentrantReadWriterLock
- Semaphore

AQS使用一个int成员变量表示同步状态，通过内置的FIFIO队列来完成`资源获取线程`的排队工作。

> 并发包的大师DougLea期望它能够成为实现大部分同步需求的基础。

## AQS的使用方式和其中的设计模式

