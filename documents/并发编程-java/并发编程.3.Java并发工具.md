[TOC]

# 分而治之 Fork-Join

## 原理

 - Fork

   首先将一个大问题分割成一系列无关联**[互相独立]**且与原问题形式相同的小问题，然后[递归地|并行地]解决这些子问题。

- Join
   最后将所有子问题的解合并得到原问题的解。

### 工作密取

现代计算机线程数往往是CPU的1~2倍。

当多条线程并行地执行任务时，可能部分线程先完成自己的Task Queue。这时率先执行完Task Queue的线程就会帮助它的小伙伴，从小伙伴的"书包"**最底下**拿出一本作业，做完这项作业后又塞回“书包”**最底下**。

***通过`工作密取`的方式减少线程阻塞或闲置的时间，提高CPU利用率。***



- 即便通过Fork-Join思想将任务划分成大小相同的小问题，但线程完成速度依然可能存在差异

比如`1+2+3+......+999999`

我们可以将其拆分成`1+2`，`3+4`......，`999998+999999`，很明显我们在计算`1+2`的速度远远快于`999998+999999`，计算机也存在这样的情况。所以采用`工作密取`的方式解决实际问题是有必要的。

## 场景

   - 大数据 `MapReduce`
   - 快速排序
   - 归并排序
   - 二分查找

> 十大计算机经典算法：
>
> ​	快速排序、堆排序、归并排序、二分查找、线性查找、深度优先、广度优先、Dijkstra、动态规划、朴素贝叶斯分类

## 使用

> - 20190702 
>
>   也许Fork-Join的本质是`多线程递归`。

- 任务

  `public abstract class ForkJoinTask<V>`

  - 有返回值的任务 

    ReursiveTask

  - 无返回值的任务 

    ```java
    public abstract class RecursiveAction extends ForkJoinTask<Void>
    ```

- 任务池 

  `public class ForkJoinPool extends AbstractExecutorService`。

  `Task`需要通过ForkJoinPool执行，使用submit或invoke提交。

  - invoke 同步执行
  - submit 异步执行

  使用`ForkJoinTask`时得到任务完成结果，我们将调用join()或者get()方法。

  - join 将阻塞当前线程

  

  - invokeAll

  每个`Task`在调用`invokeAll`方法时又会进入compute方法，查看当前任务是否可继续分割。

  ``` java
  // 两个任务
  public static void invokeAll(ForkJoinTask<?> t1, ForkJoinTask<?> t2)
  // 可变参数
  public static void invokeAll(ForkJoinTask<?>... tasks)
  // 集合
  public static <T extends ForkJoinTask<?>> Collection<T> invokeAll(Collection<T> tasks) 
  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
  ```

### 异步RecursiveAction

- 遍历指定目录（含子目录）查找指定类型文件

``` java

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveAction;

/**
 * 无返回值的分治编程
 * 遍历指定目录（含子目录）查找指定类型文件
 */
public class FindDirsFiles extends RecursiveAction {

    private String fileType;
    private File path;

    public FindDirsFiles(File path, String fileType) {
        this.path = path;
        this.fileType = fileType;
    }

    /**
     * 执行任务
     */
    @Override
    protected void compute() {
        List<FindDirsFiles> subTasks = new ArrayList<>();

        File[] files = path.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    // 对每个子目录都新建一个子任务
                    subTasks.add(new FindDirsFiles(file, fileType));
                } else {
                    // 遇到文件 检查
                    if (file.getAbsolutePath().endsWith(fileType)) {
                        System.out.println("文件:" + file.getAbsolutePath());
                    }
                }
                if (!subTasks.isEmpty()) {
                    // 在当前的 ForkJoinPool 上调度所有的子任务。
                    for (FindDirsFiles subTask : invokeAll(subTasks)) {
                        subTask.join();
                    }
                }
            }
        };
    }

    public static void main(String [] args){
        long timeVar = System.currentTimeMillis();
        // 用一个 ForkJoinPool 实例调度总任务
        ForkJoinPool pool = new ForkJoinPool();
        FindDirsFiles task = new FindDirsFiles(new File("C:\\"), "md");

        /**
         * 异步提交
         * 与主线程中工作并行执行
         */
         pool.execute(task);

        /*主线程做自己的业务工作*/
        System.out.println("Task is Running......");
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int otherWork = 0;

        for(int i=0;i<100;i++){
            otherWork = otherWork+i;
        }
        System.out.println("Main Thread done sth......,otherWork="
                +otherWork);
        task.join();//阻塞方法 Fork-Join任务完成后才执行之后代码 sout("Task end")
        System.out.println("Task end");
        System.out.println("任务耗时:" + (System.currentTimeMillis() - timeVar) + "ms");
    }
}
```

### 同步RecursiveTask