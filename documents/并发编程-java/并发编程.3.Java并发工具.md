[TOC]

# Fork-Join 分而治之

## 适用场景

- 单任务较耗时
- 任务量比较大

## 原理

 - Fork

   首先将一个大问题分割成一系列无关联**[互相独立]**且与原问题形式相同的小问题，然后[递归地|并行地]解决这些子问题。

- Join
   最后将所有子问题的解合并得到原问题的解。

### 工作密取

现代计算机线程数往往是CPU的1~2倍。

当多条线程并行地执行任务时，可能部分线程先完成自己的Task Queue。这时率先执行完Task Queue的线程就会帮助它的小伙伴，从小伙伴的"书包"**最底下**拿出一本作业，做完这项作业后又塞回“书包”**最底下**。

***通过`工作密取`的方式减少线程阻塞或闲置的时间，提高CPU利用率。***



- 即便通过Fork-Join思想将任务划分成大小相同的小问题，但线程完成速度依然可能存在差异

比如`1+2+3+......+999999`

我们可以将其拆分成`1+2`，`3+4`......，`999998+999999`，很明显我们在计算`1+2`的速度远远快于`999998+999999`，计算机也存在这样的情况。所以采用`工作密取`的方式解决实际问题是有必要的。

## 应用场景

   - 大数据 `MapReduce`
   - 快速排序
   - 归并排序
   - 二分查找

> 十大计算机经典算法：
>
> ​	快速排序、堆排序、归并排序、二分查找、线性查找、深度优先、广度优先、Dijkstra、动态规划、朴素贝叶斯分类

## 使用

> - 20190702 
>
>   也许Fork-Join的本质是`多线程递归`。

- 任务池 

  `public class ForkJoinPool extends AbstractExecutorService`。

  `Task`需要通过ForkJoinPool执行，使用submit或invoke提交。 

  - invoke 同步执行

  - submit/execute 异步执行

    此处的同步与异步控制的是`任务线程`与`启动线程`之间的次序
    
    > `pool.execute()`与`pool.submit()`的差异在于有无返回值

- 任务

  `public abstract class ForkJoinTask<V>`

  - 有返回值的任务 

    ReursiveTask

  - 无返回值的任务 

    ```java
    public abstract class RecursiveAction extends ForkJoinTask<Void>
    ```
  使用`ForkJoinTask`时得到任务完成结果，我们将调用join()或者get()方法。

  - join 将阻塞当前线程

    > `task.get()`方法效果相似，但需要程序员手动捕捉阻塞异常

  - invokeAll

  每个`Task`在调用`invokeAll`方法时又会进入compute方法，查看当前任务是否可继续分割。

  ``` java
  // 两个任务
  public static void invokeAll(ForkJoinTask<?> t1, ForkJoinTask<?> t2)
  // 可变参数
  public static void invokeAll(ForkJoinTask<?>... tasks)
  // 集合
  public static <T extends ForkJoinTask<?>> Collection<T> invokeAll(Collection<T> tasks) 
  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
  ```



### 异步RecursiveAction

- 遍历指定目录（含子目录）查找指定类型文件

``` java

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveAction;

/**
 * 无返回值的分治编程
 * 遍历指定目录（含子目录）查找指定类型文件
 */
public class FindDirsFiles extends RecursiveAction {

    private String fileType;
    private File path;

    public FindDirsFiles(File path, String fileType) {
        this.path = path;
        this.fileType = fileType;
    }

    /**
     * 执行任务
     */
    @Override
    protected void compute() {
        List<FindDirsFiles> subTasks = new ArrayList<>();

        File[] files = path.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    // 对每个子目录都新建一个子任务
                    subTasks.add(new FindDirsFiles(file, fileType));
                } else {
                    // 遇到文件 检查
                    if (file.getAbsolutePath().endsWith(fileType)) {
                        System.out.println("文件:" + file.getAbsolutePath());
                    }
                }
                if (!subTasks.isEmpty()) {
                    // 在当前的 ForkJoinPool 上调度所有的子任务。
                    for (FindDirsFiles subTask : invokeAll(subTasks)) {
                        subTask.join();
                    }
                }
            }
        };
    }

    public static void main(String [] args){
        long timeVar = System.currentTimeMillis();
        // 用一个 ForkJoinPool 实例调度总任务
        ForkJoinPool pool = new ForkJoinPool();
        FindDirsFiles task = new FindDirsFiles(new File("C:\\"), "md");

        /**
         * 异步提交
         * 与主线程中工作并行执行
         */
         pool.execute(task);

        /*主线程做自己的业务工作*/
        System.out.println("Task is Running......");
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int otherWork = 0;

        for(int i=0;i<100;i++){
            otherWork = otherWork+i;
        }
        System.out.println("Main Thread done sth......,otherWork="
                +otherWork);
        
        task.join();//阻塞方法 Fork-Join任务完成后才执行之后代码 sout("Task end")
        System.out.println("Task end");
        System.out.println("任务耗时:" + (System.currentTimeMillis() - timeVar) + "ms");
    }
}
```

尝试注释代码`task.join();`后发现遍历任务未完成，主线程结束时推出程序。可推出

- ForkJoinPool中线程为守护线程

### 同步RecursiveTask

- 产生随机数

``` java
import java.util.Random;

/**
 * 生成随机数队列数组
 */
public class MakeArray {
    // 数组长度
    public static final int ARRAY_LENGTH = 100;
    public static final int THRESHOLD = 47;

    public static int[] makeArray() {
        Random random = new Random(); // 随机数产生器
        int[] result = new int[ARRAY_LENGTH];
        for (int i = 0; i < ARRAY_LENGTH ; i++) {
            result[i] = random.nextInt(ARRAY_LENGTH * 3);
        }
        return result;
    }
}
```
- Fork-Join实现累加
``` java
import java.util.concurrent.RecursiveTask;
import java.util.concurrent.TimeUnit;

public class SumTask extends RecursiveTask<Integer> {
    /**
     * 阈值 即每份任务量的大小
     */
    private final static int THRESHOLD = MakeArray.ARRAY_LENGTH/10;
    private int[] src;
    private int fromIndex;
    private int toIndex;

    public SumTask(int[] src, int fromIndex, int toIndex) {
        this.src = src;
        this.fromIndex = fromIndex;
        this.toIndex = toIndex;
    }

    @Override
    protected Integer compute() {
        /**
         * 任务的大小是否合适
         */
        if (toIndex - fromIndex < THRESHOLD) {
            System.out.println(" from index = " + fromIndex + " toIndex =" + toIndex);
            int count = 0;
            for (int i = fromIndex; i <= toIndex ; i++) {
                /**
                 * 假设每次操作耗时较大时
                 */
                try {
                    TimeUnit.MILLISECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                count += src[i];
            }
            return count;
        } else {
            int mid = (fromIndex + toIndex)/2;
            SumTask left = new SumTask(src, fromIndex, mid);// 二分
            SumTask right = new SumTask(src, mid + 1, toIndex);
            invokeAll(left, right);
            // 阻塞方法
            return left.join() + right.join();
        }
    }
}
```

- 单线程与Fork-Join对比

``` java
import org.junit.Test;

import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.TimeUnit;

public class SumTest {
    /**
     * 单线程累加
     */
    @Test
    public void singleSum () {
        int count = 0;
        int[] src = MakeArray.makeArray();

        long start = System.currentTimeMillis();
        for (int i : src) {
            try {
                TimeUnit.MILLISECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            count += i;
        }
        System.out.println("The count is " + count);
        System.out.println("spend time:" + (System.currentTimeMillis()-start) + "ms");
    }

    @Test
    public void forkJoinSum () {
        ForkJoinPool pool = new ForkJoinPool();
        int[] src = MakeArray.makeArray();
        SumTask innerFind = new SumTask(src, 0, src.length - 1);

        long start = System.currentTimeMillis();

        // 同步
        pool.invoke(innerFind);
        System.out.println("The count is " + innerFind.join());
        System.out.println("spend time:" + (System.currentTimeMillis() - start) + "ms");
    }
}
```

# CountDownLatch

- countdown 倒数
- latch 门闩；碰锁

`CountDownLatch`能够使一个线程等待其他线程完成各自的工作后再执行。

`CountDownLatch`通过一个计数器实现，计数器的初始值为出师任务的数量。每完成一个任务后，调用`countDown()`方法，计数器的值就会减一。当计数器的值为零时，在闭锁上等待`await()`方法的线程就可以恢复执行任务。

## 应用场景

例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。

## 代码

``` java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 *类说明：演示CountDownLatch用法，
 * 共5个初始化子线程，6个闭锁扣除点，扣除完毕后，主线程和业务线程才能继续执行
 */
public class UseCountDownLatch {

    static CountDownLatch latch = new CountDownLatch(6);

    /*初始化线程*/
    private static class InitThread implements Runnable{

        public void run() {
            System.out.println("Thread_"+Thread.currentThread().getId()
                    +" ready init work......");
            latch.countDown();
            for(int i =0;i<2;i++) {
                System.out.println("Thread_"+Thread.currentThread().getId()
                        +" ........continue do its work");
            }
        }
    }

    /*业务线程等待latch的计数器为0完成*/
    private static class BusiThread implements Runnable{

        public void run() {
            try {
                latch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            for(int i =0;i<3;i++) {
                System.out.println("BusiThread_"+Thread.currentThread().getId()
                        +" do business-----");
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        new Thread(new Runnable() {
            public void run() {
                try {
                    TimeUnit.MILLISECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread_"+Thread.currentThread().getId()
                        +" ready init work step 1st......");
                latch.countDown();
                System.out.println("begin step 2nd.......");
                try {
                    TimeUnit.MILLISECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread_"+Thread.currentThread().getId()
                        +" ready init work step 2nd......");
                latch.countDown();
            }
        }).start();
        new Thread(new BusiThread()).start();
        for(int i=0;i<=3;i++){
            Thread thread = new Thread(new InitThread());
            thread.start();
        }

        latch.await();
        System.out.println("Main do ites work........");
    }
}
```

