[TOC]

# Fork-Join 分而治之

## 适用场景

- 单任务较耗时
- 任务量比较大

## 原理

 - Fork

   首先将一个大问题分割成一系列无关联**[互相独立]**且与原问题形式相同的小问题，然后[递归地|并行地]解决这些子问题。

- Join
   最后将所有子问题的解合并得到原问题的解。

### 工作密取

现代计算机线程数往往是CPU的1~2倍。

当多条线程并行地执行任务时，可能部分线程先完成自己的Task Queue。这时率先执行完Task Queue的线程就会帮助它的小伙伴，从小伙伴的"书包"**最底下**拿出一本作业，做完这项作业后又塞回“书包”**最底下**。

***通过`工作密取`的方式减少线程阻塞或闲置的时间，提高CPU利用率。***



- 即便通过Fork-Join思想将任务划分成大小相同的小问题，但线程完成速度依然可能存在差异

比如`1+2+3+......+999999`

我们可以将其拆分成`1+2`，`3+4`......，`999998+999999`，很明显我们在计算`1+2`的速度远远快于`999998+999999`，计算机也存在这样的情况。所以采用`工作密取`的方式解决实际问题是有必要的。

## 应用场景

   - 大数据 `MapReduce`
   - 快速排序
   - 归并排序
   - 二分查找

> 十大计算机经典算法：
>
> ​	快速排序、堆排序、归并排序、二分查找、线性查找、深度优先、广度优先、Dijkstra、动态规划、朴素贝叶斯分类

## 使用

> - 20190702 
>
>   也许Fork-Join的本质是`多线程递归`。

- 任务池 

  `public class ForkJoinPool extends AbstractExecutorService`。

  `Task`需要通过ForkJoinPool执行，使用submit或invoke提交。 

  - invoke 同步执行

  - submit/execute 异步执行

    此处的同步与异步控制的是`任务线程`与`启动线程`之间的次序
    
    > `pool.execute()`与`pool.submit()`的差异在于有无返回值

- 任务

  `public abstract class ForkJoinTask<V>`

  - 有返回值的任务 

    ReursiveTask

  - 无返回值的任务 

    ```java
    public abstract class RecursiveAction extends ForkJoinTask<Void>
    ```
  使用`ForkJoinTask`时得到任务完成结果，我们将调用join()或者get()方法。

  - join 将阻塞当前线程

    > `task.get()`方法效果相似，但需要程序员手动捕捉阻塞异常

  - invokeAll

  每个`Task`在调用`invokeAll`方法时又会进入compute方法，查看当前任务是否可继续分割。

  ``` java
  // 两个任务
  public static void invokeAll(ForkJoinTask<?> t1, ForkJoinTask<?> t2)
  // 可变参数
  public static void invokeAll(ForkJoinTask<?>... tasks)
  // 集合
  public static <T extends ForkJoinTask<?>> Collection<T> invokeAll(Collection<T> tasks) 
  public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)
  ```



### 异步RecursiveAction

- 遍历指定目录（含子目录）查找指定类型文件

``` java

import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveAction;

/**
 * 无返回值的分治编程
 * 遍历指定目录（含子目录）查找指定类型文件
 */
public class FindDirsFiles extends RecursiveAction {

    private String fileType;
    private File path;

    public FindDirsFiles(File path, String fileType) {
        this.path = path;
        this.fileType = fileType;
    }

    /**
     * 执行任务
     */
    @Override
    protected void compute() {
        List<FindDirsFiles> subTasks = new ArrayList<>();

        File[] files = path.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    // 对每个子目录都新建一个子任务
                    subTasks.add(new FindDirsFiles(file, fileType));
                } else {
                    // 遇到文件 检查
                    if (file.getAbsolutePath().endsWith(fileType)) {
                        System.out.println("文件:" + file.getAbsolutePath());
                    }
                }
                if (!subTasks.isEmpty()) {
                    // 在当前的 ForkJoinPool 上调度所有的子任务。
                    for (FindDirsFiles subTask : invokeAll(subTasks)) {
                        subTask.join();
                    }
                }
            }
        };
    }

    public static void main(String [] args){
        long timeVar = System.currentTimeMillis();
        // 用一个 ForkJoinPool 实例调度总任务
        ForkJoinPool pool = new ForkJoinPool();
        FindDirsFiles task = new FindDirsFiles(new File("C:\\"), "md");

        /**
         * 异步提交
         * 与主线程中工作并行执行
         */
         pool.execute(task);

        /*主线程做自己的业务工作*/
        System.out.println("Task is Running......");
        try {
            Thread.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        int otherWork = 0;

        for(int i=0;i<100;i++){
            otherWork = otherWork+i;
        }
        System.out.println("Main Thread done sth......,otherWork="
                +otherWork);
        
        task.join();//阻塞方法 Fork-Join任务完成后才执行之后代码 sout("Task end")
        System.out.println("Task end");
        System.out.println("任务耗时:" + (System.currentTimeMillis() - timeVar) + "ms");
    }
}
```

尝试注释代码`task.join();`后发现遍历任务未完成，主线程结束时推出程序。可推出

- ForkJoinPool中线程为守护线程

### 同步RecursiveTask

- 产生随机数

``` java
import java.util.Random;

/**
 * 生成随机数队列数组
 */
public class MakeArray {
    // 数组长度
    public static final int ARRAY_LENGTH = 100;
    public static final int THRESHOLD = 47;

    public static int[] makeArray() {
        Random random = new Random(); // 随机数产生器
        int[] result = new int[ARRAY_LENGTH];
        for (int i = 0; i < ARRAY_LENGTH ; i++) {
            result[i] = random.nextInt(ARRAY_LENGTH * 3);
        }
        return result;
    }
}
```
- Fork-Join实现累加
``` java
import java.util.concurrent.RecursiveTask;
import java.util.concurrent.TimeUnit;

public class SumTask extends RecursiveTask<Integer> {
    /**
     * 阈值 即每份任务量的大小
     */
    private final static int THRESHOLD = MakeArray.ARRAY_LENGTH/10;
    private int[] src;
    private int fromIndex;
    private int toIndex;

    public SumTask(int[] src, int fromIndex, int toIndex) {
        this.src = src;
        this.fromIndex = fromIndex;
        this.toIndex = toIndex;
    }

    @Override
    protected Integer compute() {
        /**
         * 任务的大小是否合适
         */
        if (toIndex - fromIndex < THRESHOLD) {
            System.out.println(" from index = " + fromIndex + " toIndex =" + toIndex);
            int count = 0;
            for (int i = fromIndex; i <= toIndex ; i++) {
                /**
                 * 假设每次操作耗时较大时
                 */
                try {
                    TimeUnit.MILLISECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                count += src[i];
            }
            return count;
        } else {
            int mid = (fromIndex + toIndex)/2;
            SumTask left = new SumTask(src, fromIndex, mid);// 二分
            SumTask right = new SumTask(src, mid + 1, toIndex);
            invokeAll(left, right);
            // 阻塞方法
            return left.join() + right.join();
        }
    }
}
```

- 单线程与Fork-Join对比

``` java
import org.junit.Test;

import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.TimeUnit;

public class SumTest {
    /**
     * 单线程累加
     */
    @Test
    public void singleSum () {
        int count = 0;
        int[] src = MakeArray.makeArray();

        long start = System.currentTimeMillis();
        for (int i : src) {
            try {
                TimeUnit.MILLISECONDS.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            count += i;
        }
        System.out.println("The count is " + count);
        System.out.println("spend time:" + (System.currentTimeMillis()-start) + "ms");
    }

    @Test
    public void forkJoinSum () {
        ForkJoinPool pool = new ForkJoinPool();
        int[] src = MakeArray.makeArray();
        SumTask innerFind = new SumTask(src, 0, src.length - 1);

        long start = System.currentTimeMillis();

        // 同步
        pool.invoke(innerFind);
        System.out.println("The count is " + innerFind.join());
        System.out.println("spend time:" + (System.currentTimeMillis() - start) + "ms");
    }
}
```

# CountDownLatch

> 曾使用`CountDownLatch`实现在并发场景下的计时器——开启一个线程A后调用`await`进入阻塞，再通过其他线程调用`countDown()`，线程A唤醒后完成计时。

- countdown 倒数
- latch 门闩；碰锁

`CountDownLatch`能够使一个线程等待其他线程完成各自的工作后再执行。

`CountDownLatch`通过一个计数器实现，计数器的初始值为出师任务的数量。每完成一个任务后，调用`countDown()`方法，计数器的值就会减一。当计数器的值为零时，在闭锁上等待`await()`方法的线程就可以恢复执行任务。

> `countDown()`可在同一线程扣减一次或多次。

## 应用场景

例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行。

## 代码

``` java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

/**
 *类说明：演示CountDownLatch用法，
 * 共5个初始化子线程，6个闭锁扣除点，扣除完毕后，主线程和业务线程才能继续执行
 */
public class UseCountDownLatch {

    static CountDownLatch latch = new CountDownLatch(6);

    /*初始化线程*/
    private static class InitThread implements Runnable{

        public void run() {
            System.out.println("Thread_"+Thread.currentThread().getId()
                    +" ready init work......");
            latch.countDown();
            for(int i =0;i<2;i++) {
                System.out.println("Thread_"+Thread.currentThread().getId()
                        +" ........continue do its work");
            }
        }
    }

    /*业务线程等待latch的计数器为0完成*/
    private static class BusiThread implements Runnable{

        public void run() {
            try {
                latch.await();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            for(int i =0;i<3;i++) {
                System.out.println("BusiThread_"+Thread.currentThread().getId()
                        +" do business-----");
            }
        }
    }

    public static void main(String[] args) throws InterruptedException {
        new Thread(new Runnable() {
            public void run() {
                try {
                    TimeUnit.MILLISECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread_"+Thread.currentThread().getId()
                        +" ready init work step 1st......");
                latch.countDown();
                System.out.println("begin step 2nd.......");
                try {
                    TimeUnit.MILLISECONDS.sleep(1);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread_"+Thread.currentThread().getId()
                        +" ready init work step 2nd......");
                latch.countDown();
            }
        }).start();
        new Thread(new BusiThread()).start();
        for(int i=0;i<=3;i++){
            Thread thread = new Thread(new InitThread());
            thread.start();
        }

        latch.await();
        System.out.println("Main do ites work........");
    }
}
```

# CyclicBarrier

- Cyclic 反复利用的

- Barrier 屏障

一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。

每个线程调用await()告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。

> CyclicBarrier可反复利用，调用完#{parties}次后可重复使用。	

## 构造方法

CyclicBarrier（int parties），其参数表示屏障拦截的线程数量；

CyclicBarrier（int parties，Runnable barrierAction），用于在所有线程到达屏障时，优先执行`barrierAction`，方便处理更复杂的业务场景。

> `barrierAction`可用于汇总操作

## 成员方法

- reset

  可调用`reset`方法回到初始化状态。

## 代码

``` java
/**
 *类说明：演示CyclicBarrier用法,共5个子线程，他们全部完成工作后，交出自己结果，
 *再被统一释放去做自己的事情，而交出的结果被另外的线程拿来拼接字符串
 *
 * 由于PARITES == 4 而启动5个线程故可能出现一次多余的dosomething
 *
 * 注意：由于CyclicBarrier可反复使用，所以调用完4次await后可重复使用
 */
public class UseCyclicBarrier {

    private static int PARITES = 4;
    private static CyclicBarrier barrier = new CyclicBarrier(PARITES, new CollectThread());
    private static ConcurrentHashMap<String,Long> resultMap
            = new ConcurrentHashMap<>();//存放子线程工作结果的容器

    public static void main(String[] args) {
        for(int i=0;i<=PARITES;i++){
            Thread thread = new Thread(new SubThread());
            thread.start();
        }
    }

    /**
     * 汇总工作线程
     */
    private static class CollectThread implements Runnable{

        @Override
        public void run() {
            StringBuilder result = new StringBuilder();
            for(Map.Entry<String,Long> workResult:resultMap.entrySet()){
                result.append("["+workResult.getValue()+"]");
            }
            System.out.println(" the result = "+ result);
            System.out.println("do other business........");
        }
    }

    /**
     * 子任务线程
     */
    private static class SubThread implements Runnable{

        @Override
        public void run() {
            long id = Thread.currentThread().getId();
            resultMap.put(Thread.currentThread().getId()+"",id);
            try {
                Thread.sleep(1000+id);
                System.out.println("Thread_"+id+" ....do something ");
                // 所有线程调用`await`后将唤醒线程
                barrier.await();
                // 唤醒后业务工作
                Thread.sleep(1000+id);
                System.out.println("Thread_"+id+" ....do its business ");
                // barrier.await();
            } catch (Exception e) {
                e.printStackTrace();
            }

        }
    }
}
```

## CountDownLatch和CyclicBarrier辨析

- 使用次数CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以反复使用。

- CountDownLatch.await一般阻塞工作线程，所有的进行预备工作的线程执行countDown；而CyclicBarrier通过工作线程调用await从而自行阻塞，直到所有工作线程达到指定屏障，再大家一起往下走。

- 在控制多个线程同时运行上，CountDownLatch可以不限线程数量，而CyclicBarrier是固定线程数。

- 同时，CyclicBarrier还可以提供一个barrierAction，合并多线程计算结果。

# Semaphore

**流量控制场景**——保证各线程合理利用系统资源，例如TCP连接（数据库连接、FTP连接等）

例如：读取几万个文件（IO密集型），我们将启动几十个线程并发读取，但是读取到内存后，还需要存储到数据库中，而数据库连接可能仅有10个，我们必须控制10个线程同时获取数据库连接保存数据，否则可能报连接数不足错误。

使用`Semaphore`可保证任一时刻保证仅10个线程访问数据库。

## 方法

- 构造方法`Semaphore(int permits)` 

  permits表示许可证数量；

- `intavailablePermits()`

  返回此信号量中当前可用的许可证数

- `int getQueueLength()`

  返回正在等待获取许可证的线程数

- `boolean hasQueuedThreads()`

  是否有线程正在等待获取许可证

- `void reducePermits（int reduction）`

  减少许可证

- `protected Collection getQueuedThreads()`

  返回所有等待获取许可证的线程集合

## 使用步骤

1、线程首先调用`acquire`方法获得许可证；

2、线程调用`release`方法归还许可证；

3、线程调用`tryAcquire`方法再次尝试获取许可证；