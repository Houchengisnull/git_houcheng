[toc]

# 服务器推送

## pushlet

# 通信

## Apache HttpClient

https://blog.csdn.net/justry_deng/article/details/81042379

一个`Http`通信库，是`Apache Jakarta Common`的子项目。

### 基本使用

- 建立`HttpClient`

  `HttpClient`中有多重方法获得实例

  ``` java
  // 最常用的方法 创建一个实现Closeable接口的HttpClient
  CloseableHttpClient client = HttpsClient.createDefault();
  // 
  HttpClient client = HttpClientBuilder.create().build();
  // 通过custom()我们可以定制一些功能多元的HttpClient, 比如设置代理或者SSL证书(https)
  HttpClient client = HttpClients.custom().create().build();
  ```

- 创建`HttpGet`和`HttpPost`

  通常我们对请求体的设置主要针对这两种对象。

  ``` java
  HttpGet get = new HttpGet("http://127.0.0.1", 8080);
  HttpPost post = new HttpPost("http://127.0.0.1", 8080);
  /* 
  通常HttpClient已经将我们常用的Http请求属性封装好
  所以我尽量使用别人已经定义好的常量, 而非“魔数”
  */
  post.setHeader(HTTP.CONTENT_TYPE, ContentType.APPLICATION_FORM_URLENCODED.getMimeType());
  ```

- 设置`HttpEntity`

  我们的请求参数使用`HttpEntity`进行封装，以下以模拟表单为例：

  ``` java
  List<NameValuePair> list = new ArrayList<>();
  list.add(new BasicNameValuePair("name", "houchengisnull"));
  HttpEntity entity = new UrlEncodedFormEntity(list, "UTF-8");
  // post对象是一个HttpPost对象
  post.setEntity(entity);
  ```

  除表单以外，参数还常常以`application/json`的形式，

  ``` java
  // message 是一个JSON对象
  HttpEntity entity = new StringEntity(JSON.toJSONString(message), "UTF-8");
  ```

### 请求配置 RequestConfig

当我们需要设置`Http连接`的各种属性，我们需要用`HttpClient`的`RequestConfig`对象。

比如设置`超时时间`、`是否允许重定向`：

``` java
long minTime = 1000;
RequestConfig config = RequestConfig.custom()
    .setConnectionTimeout(minTime)
    .setConnectionRequestTimeout(minTime)
    .setSocketTimeout(minTime)
    .setRedirectsEnable(true)
    .build();

post.setConfig(config);
```

其中包含了一个默认的`RequestConfig`，

``` java
RequestConfig defaultConfig = RequestConfig.DEFAULTE;
```

我们可以看看生成默认请求配置`RequestConfig.DEFAULT`的实现

``` java
public static final RequestConfig DEFAULT = new Builder().build();
```

如果我们需要复制一个相同的`RequestConfig`对象，我们可以如下做：

``` java
RequestConfig config = RequestConfig.copy(RequestConfig.DEFAULT);
```

**如果我们需要设置代理进行请求**

``` java
RequestConfig config = RequestConfig.copy(RequestConfig.DEFAULT).setProxy(new HttpHost("192.168.1.x",9090));
```

### 设置代理

> 由于一台测试服务器我需要通过代理服务器才能访问，在网上测试了诸多方法后，发现只有最简单的一种切实有效。
>
> 我已经写在上面了。

``` java
RequestConfig config = RequestConfig.copy(RequestConfig.DEFAULT).setProxy(new HttpHost("192.168.1.x",9090));
```

此外，仍然有一种已经过时的方法：

``` java
HttpHost proxy = new HttpHost("192.168.1.x", 9090)
DefaultHttpClient client = new DefaultHttpClient();
client.getParams().setParameter(ConnRoutePNames.DEFAULT_PROXY, proxy); // setParameter已过时
CloseableHttpResponse response = client.execute(post);
```

另外再列举两种无效的方法，第一种如下所示：

``` java
HttpHost proxy = new HttpHost("192.168.1.x", 9090)
DefaultProxyRoutePlanner routePlanner = new DefaultProxyRoutePlanner(proxy);
HttpClients.custom().setRoutePlanner(routePlanner).create().build();
```

在这种方法失败后，我尝试获取系统的`RoutePlanner`对象：

``` java
SystemDefaultRoutePlanner planner = new SystemDefaultRoutePlanner(ProxySelector.getDefault());
```

意外的没有成功。

> 此外，我还曾想过通过设置JVM参数Java进程直接调用系统代理，同意是失败了。
>
> 拳头最有力，简单即高效。

- 参考
- <a href='www.cocoachina.com/articles/496139'>HttpRoutePlanner-如何与HTTPS代理一起使用</a>
- <a href='www.itranslater.com/qa/details/2112792934100763648'>如何设置JVM使用的代理</a>