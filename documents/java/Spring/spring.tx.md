[TOC]

# readOnly
`readOnly`并不是不能在事务中进行修改等DML操作，它只是一个“暗示”，提示数据库驱动程序和数据库系统，这个事务并不包含更改数据的操作，那么JDBC驱动程序和数据库就有可能根据这种情况对该事务进行一些特定的优化，比方说不安排相应的数据库锁，以减轻事务对数据库的压力，毕竟事务也是要消耗数据库的资源的。


## 配置

- xml

``` xml
 <tx:method name="search*" read-only="true" /> 
```

- annotation

``` java
@Transactional(readOnly = true)
```

## 特点

- readonly并不是所有数据库都支持的，不同的数据库下会有不同的结果。
- 设置了readonly后，connection都会被赋予readonly，效果取决于数据库的实现。
- 在ORM中，设置了readonly会赋予一些额外的优化，例如在Hibernate中，会被禁止flush等。

# Propagation 事务传播属性

传播行为定义关于客户端和被调用方法的事务边界。

| **传播行为**                  | **意义**                                                     |
| ----------------------------- | ------------------------------------------------------------ |
| **PROPAGATION_REQUIRES**      | 表示当前方法必须在一个事务中运行。如果一个现有事务正在进行中，该方法将在那个事务中运行，否则就要开始一个新事务。 |
| **PROPAGATION_SUPPORTS**      | 表示当前方法不需要事务性上下文，但是如果有一个事务已经在运行的话，它也可以在这个事务里运行。 |
| **PROPAGATION_MANDATORY**     | 表示该方法必须运行在一个事务中。如果当前没有事务正在发生，将抛出一个异常。 |
| **PROPAGATION_REQUIRES_NEW**  | 表示当前方法必须在它自己的事务里运行。一个新的事务将被启动，而且如果有一个现有事务在运行的话，则将在这个方法运行期间被挂起。 |
| **PROPAGATION_NOT_SUPPORTED** | 表示当前方法不需要事务性上下文，但是如果有一个事务已经在运行的话，它也可以在这个事务里运行。 |
| **PROPAGATION_NEVER**         | 表示当前的方法不应该在一个事务中运行。如果一个事务正在进行，则会抛出一个异常。 |
| **PROPAGATION_NESTED**        | 表示如果当前正有一个事务在进行中，则该方法应当运行在一个嵌套式事务中。被嵌套的事务可以独立于封装事务进行提交或回滚。如果封装事务不存在，行为就像PROPAGATION_REQUIRES一样。 |

# Isolation 事务隔离属性

| **隔离级别**                   | **含义**                                                     |
| ------------------------------ | ------------------------------------------------------------ |
| **ISOLATION_DEFAULT**          | 使用后端数据库默认的隔离级别。                               |
| **ISOLATION_READ_UNCOMMITTED** | 允许读取尚未提交的更改。可能导致脏读、幻影读或不可重复读。   |
| **ISOLATION_READ_COMMITTED**   | 允许从已经提交的并发事务读取。可防止脏读，但幻影读和不可重复读仍可能会发生。 |
| **ISOLATION_REPEATABLE_READ**  | 对相同字段的多次读取的结果是一致的，除非数据被当前事务本身改变。可防止脏读和不可重复读，但幻影读仍可能发生。 |
| **ISOLATION_SERIALIZABLE**     | 完全服从ACID的隔离级别，确保不发生脏读、不可重复读和幻影读。这在所有隔离级别中也是最慢的，因为它通常是通过完全锁定当前事务所涉及的数据表来完成的。 |

## 参考

https://www.cnblogs.com/qiumingcheng/p/9301431.html