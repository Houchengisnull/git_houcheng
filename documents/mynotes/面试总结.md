[toc]

# 面试总结

## 并发

### sleep与wait方法不同

- `wait()`属于`class Object`方法 ，`sleep()`属于`class Thread`方法；
- `wait()`将释放锁，`sleep()`将持有锁；
- `wait()`通常用于线程间交互，`sleep()`通常用于暂停执行；

### Synchronized与Lock区别

- `synchronized`是`java`关键字，`Lock`是`java`接口；
- `synchronized`不需要用户手动释放锁，`Lock`需要用户手动释放锁，否则可能导致死锁现象；
- `synchronized`是不可中断锁，`Lock`是可中断锁；
- `synchronized`未非公平锁，`Lock`默认情况下为非公平锁，但可设置公平锁；
- `Lock`可返回是否获得锁；
- `Lock`可设置等待锁时间；

## Spring



### SpringMVC

#### 什么是springMVC

`SpringMVC`是`spring`一个模块，基于MVC的一个框架。

#### SpringMVC工作原理

- 用户发送请求至前端控制器 `DispatcherServlet`。 

- `DispatcherServlet`收到请求调用`HandlerMapping`处理器映射器。

- `HandlerMapping`找到具体的处理器(可以根据xml 配置、注解进行查找)，生成处理器对象

及处理器拦截器(如果有则生成)一并返回给 DispatcherServlet。 

- `DispatcherServlet`调用 `HandlerAdapter `处理器适配器。

- `HandlerAdapter` 经过适配调用具体的处理器(Controller，也叫后端控制器)。 

- `Controller` 执行完成返回 `ModelAndView`。
- `HandlerAdapter` 将 controller 执行结果`ModelAndView` 返回给`DispatcherServlet`。 

- `DispatcherServlet`将`ModelAndView`传给`ViewReslover` 视图解析器。

- `ViewReslover`解析后返回具体`View`。

- `DispatcherServlet`根据`View`进行渲染视图（即将模型数据填充至视图中）。

- `DispatcherServlet`响应用户。

#### SpringMVC作用

- 解耦

#### SpringMVC背景

早期`Java Web` 开发中，将显示层、控制层、数据层的操作全部交给`JSP`或者`Java Bean`。

结果代码出现严重耦合——JSP与Java Bean、Java代码和前端代码耦合在了一起。

导致一下问题：

  - 前后端相互依赖
  - 代码难以复用

于是这种方式被`servlet`+`jsp`+`java bean`替代了。这也是最早的`MVC模型`。

#### 核心组件

##### 视图解析器 `ViewResolver`

- xml配置

  ``` xml
  <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
  
  <property name="viewClass"
  
  value="org.springframework.web.servlet.view.JstlView" />
  
  <property name="prefix" value="/WEB-INF/jsp/" />
  
  <property name="suffix" value=".jsp" />
  
  </bean>
  ```

个人理解，将（`Controller`/`Handler`/`HandlerAdapter`返回的`ModelAndView`中的）`View`配上`prefiex`属性和`suffix`属性以找到相应视图。

##### 处理映射器 HandlerMapping

- 配置

  ``` xml
  <bean id="handlerMapping" class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping">
      <property name="mappings">
          <props>
              <prop key="/toHello.do">helloController</prop>
          </props>
      </property>
  </bean>
  
  <!-- 配置控制器 -->
  <bean id="helloController" class="com.xcz.controller.ToHelloController"></bean>
  ```

##### DispatcherServlet

``` java
//前端控制器分派方法  
protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception {  
        HttpServletRequest processedRequest = request;  
        HandlerExecutionChain mappedHandler = null;  
        int interceptorIndex = -1;
        try {  
            ModelAndView mv;  
            boolean errorView = false;    
            try {  
        //检查是否是请求是否是multipart（如文件上传），如果是将通过MultipartResolver解析  
                processedRequest = checkMultipart(request);  
        //步骤2、请求到处理器（页面控制器）的映射，通过HandlerMapping进行映射  
                mappedHandler = getHandler(processedRequest, false);  
                if (mappedHandler == null || mappedHandler.getHandler() == null) {  
                    noHandlerFound(processedRequest, response);  
                    return;  
                }  
 		//步骤3、处理器适配，即将我们的处理器包装成相应的适配器（从而支持多种类型的处理器）  
                HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());    
                // 304 Not Modified缓存支持  
                // 此处省略具体代码    
                // 执行处理器相关的拦截器的预处理（HandlerInterceptor.preHandle）  
                // 此处省略具体代码    
                // 步骤4、由适配器执行处理器（调用处理器相应功能处理方法）  
                mv = ha.handle(processedRequest, response, mappedHandler.getHandler());    
                // Do we need view name translation?  
                if (mv != null && !mv.hasView()) {  
                    mv.setViewName(getDefaultViewName(request));  
                }    
                // 执行处理器相关的拦截器的后处理（HandlerInterceptor.postHandle）  
                //此处省略具体代码  
            }  
            catch (ModelAndViewDefiningException ex) {  
                logger.debug("ModelAndViewDefiningException encountered", ex);  
                mv = ex.getModelAndView();  
            }  
            catch (Exception ex) {  
                Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);  
                mv = processHandlerException(processedRequest, response, handler, ex);  
                errorView = (mv != null);  
            }    
				//步骤5 步骤6、解析视图并进行视图的渲染  
				//步骤5 由ViewResolver解析View（viewResolver.resolveViewName(viewName, locale)）  
            	//步骤6 视图在渲染时会把Model传入
			（view.render(mv.getModelInternal(), request, response);）  
            if (mv != null && !mv.wasCleared()) {  
                render(mv, processedRequest, response);  
                if (errorView) {  
                    WebUtils.clearErrorRequestAttributes(request);  
                }  
            }  
            else {  
                if (logger.isDebugEnabled()) {  
                    logger.debug("Null ModelAndView returned to DispatcherServlet with name '" + getServletName() +  
                            "': assuming HandlerAdapter completed request handling");  
                }  
            }    
            // 执行处理器相关的拦截器的完成后处理（HandlerInterceptor.afterCompletion）  
            // 此处省略具体代码    
        catch (Exception ex) {  
            // Trigger after-completion for thrown exception.  
            triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex)            throw ex;  
        }  
        catch (Error err) {  
            ServletException ex = new NestedServletException("Handler processing failed", err);  
            // Trigger after-completion for thrown exception.  
            triggerAfterCompletion(mappedHandler, interceptorIndex, processedRequest, response, ex);  
            throw ex;  
        }    
        finally {  
            // Clean up any resources used by a multipart request.  
            if (processedRequest != request) {
                cleanupMultipart(processedRequest);  
            }  
        }  
    }  
```

### 事务

#### 实现原理



